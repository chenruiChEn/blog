{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/material-x/source/style.less","path":"style.less","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/LICENSE.txt","path":"fontawesome-free-5.6.3-web/LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/material-x/source/fonts/Monaco.ttf","path":"fonts/Monaco.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/material-x/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/material-x/source/js/volantis.js","path":"js/volantis.js","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/all.min.css","path":"fontawesome-free-5.6.3-web/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/brands.css","path":"fontawesome-free-5.6.3-web/css/brands.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/brands.min.css","path":"fontawesome-free-5.6.3-web/css/brands.min.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/fontawesome.min.css","path":"fontawesome-free-5.6.3-web/css/fontawesome.min.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/regular.css","path":"fontawesome-free-5.6.3-web/css/regular.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/regular.min.css","path":"fontawesome-free-5.6.3-web/css/regular.min.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/solid.css","path":"fontawesome-free-5.6.3-web/css/solid.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/solid.min.css","path":"fontawesome-free-5.6.3-web/css/solid.min.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/svg-with-js.css","path":"fontawesome-free-5.6.3-web/css/svg-with-js.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/svg-with-js.min.css","path":"fontawesome-free-5.6.3-web/css/svg-with-js.min.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/v4-shims.css","path":"fontawesome-free-5.6.3-web/css/v4-shims.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/v4-shims.min.css","path":"fontawesome-free-5.6.3-web/css/v4-shims.min.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.eot","path":"fontawesome-free-5.6.3-web/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.woff","path":"fontawesome-free-5.6.3-web/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.ttf","path":"fontawesome-free-5.6.3-web/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.woff2","path":"fontawesome-free-5.6.3-web/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/all.css","path":"fontawesome-free-5.6.3-web/css/all.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/fontawesome.css","path":"fontawesome-free-5.6.3-web/css/fontawesome.css","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.woff","path":"fontawesome-free-5.6.3-web/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.woff2","path":"fontawesome-free-5.6.3-web/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.woff","path":"fontawesome-free-5.6.3-web/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.woff2","path":"fontawesome-free-5.6.3-web/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/material-x/source/fonts/Skranji-Regular.ttf","path":"fonts/Skranji-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.eot","path":"fontawesome-free-5.6.3-web/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.ttf","path":"fontawesome-free-5.6.3-web/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.svg","path":"fontawesome-free-5.6.3-web/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.eot","path":"fontawesome-free-5.6.3-web/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.ttf","path":"fontawesome-free-5.6.3-web/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/fonts/Ubuntu-Regular.ttf","path":"fonts/Ubuntu-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.svg","path":"fontawesome-free-5.6.3-web/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.svg","path":"fontawesome-free-5.6.3-web/webfonts/fa-solid-900.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/material-x/.gitignore","hash":"f875b6524d4c61e5de0a1d9efdec1fe451d7bc07","modified":1547517169000},{"_id":"themes/material-x/LICENSE","hash":"13b0862f4ed1914abe887a47df2c3ca5adfa8f3f","modified":1547517169000},{"_id":"themes/material-x/README.md","hash":"b497d2c298d6ca35c5ccf9793baa0ceab77b64bf","modified":1547517169000},{"_id":"themes/material-x/_config.yml","hash":"b7bfd88b609a91d40901610ba44bfdd7bb5012e0","modified":1548815477000},{"_id":"source/_posts/3.0 css 代码规范.md","hash":"03336ceac9f3019500278088828005aee2c1c75f","modified":1547534527000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1547516691000},{"_id":"source/_posts/解决各种IE兼容.md","hash":"f9cdd878b08ab99c31c043f829bc54c91aef189c","modified":1547534454000},{"_id":"themes/material-x/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1547517169000},{"_id":"themes/material-x/.git/config","hash":"c154ce28242e1086bb810b259f1f50738bfce101","modified":1547517169000},{"_id":"themes/material-x/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1547516922000},{"_id":"themes/material-x/.git/index","hash":"1e58f0a5717318bef75fd63a40787c59ee2c169a","modified":1547517169000},{"_id":"themes/material-x/.git/packed-refs","hash":"ec6692641ba3705fa5c9c28c2648f5336afacea3","modified":1547517169000},{"_id":"themes/material-x/languages/en.yml","hash":"d5694e466d80e1968be1c53cd02859e49b105fa2","modified":1547517169000},{"_id":"themes/material-x/languages/zh-HK.yml","hash":"5a4ed9ed01b32b483cc5d0cb0bdd90ac6551885c","modified":1547517169000},{"_id":"themes/material-x/languages/zh-CN.yml","hash":"49c82b156a55212ac19ed60cf5d3ec6d025fa61f","modified":1547517169000},{"_id":"themes/material-x/languages/zh-TW.yml","hash":"2fae3f9c42087d5fd10948f54bb830c420f2a1a4","modified":1547517169000},{"_id":"themes/material-x/layout/archive.ejs","hash":"80df589f63d1639ef1a320a610804fd88a64c4a9","modified":1547517169000},{"_id":"themes/material-x/layout/category.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1547517169000},{"_id":"themes/material-x/layout/index.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1547517169000},{"_id":"themes/material-x/layout/layout.ejs","hash":"949b5ab6f5de8d066e961a431a7d68947298f5e6","modified":1547517169000},{"_id":"themes/material-x/layout/links.ejs","hash":"32ed59ee4e692eb23df79d499c8ebd3160da56fc","modified":1547517169000},{"_id":"themes/material-x/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1547517169000},{"_id":"themes/material-x/layout/post.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1547517169000},{"_id":"themes/material-x/layout/tag.ejs","hash":"c97be36b33bb44957778587f00c978f2d28016f8","modified":1547517169000},{"_id":"themes/material-x/source/style.less","hash":"23ac5e1746b526d5c47a9ecad3cfccad3d0fb898","modified":1547517169000},{"_id":"themes/material-x/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1547516922000},{"_id":"themes/material-x/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1547516922000},{"_id":"themes/material-x/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1547516922000},{"_id":"themes/material-x/.git/logs/HEAD","hash":"df59aa8b04e9b5453fc872c97bdb8128020b9f50","modified":1547517169000},{"_id":"themes/material-x/.github/ISSUE_TEMPLATE/------.md","hash":"9c7e7f3d857ae3884d2b5a4b929b209b704d1929","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/archive.ejs","hash":"865f8da40dd3e7d7c30311190050b85305c1b78f","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/article.ejs","hash":"2303095f43982c1d5be0d1dbe622d8dc6efb902c","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/footer.ejs","hash":"90a4255a01a3ae46264549fe7114f67277d06d8b","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/categories.ejs","hash":"12b2fca703fa56da7a85045bf17499845c3fe5bb","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/head.ejs","hash":"5ed07f772554a123fb9256ca8427c399794e3117","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/header.ejs","hash":"2e184dacc1c62b45614931e50a8a3334e9aa5979","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/loading.ejs","hash":"4afd88877fe7339269f34ccca6437659dd5e0cb1","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/mathjax.ejs","hash":"e3b0e76b70ac2ea3377bfc2571a2c81ea42a3e01","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/meta.ejs","hash":"392d7d5b030febd7232af87f3036582daafd7471","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/post.ejs","hash":"f6e348e5679651d8e509829bc90999fc2f97cc26","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/scripts.ejs","hash":"b000d48e92f9b9ac8966f46bdd57b17dc52cc6aa","modified":1547517169000},{"_id":"themes/material-x/layout/_partial/side.ejs","hash":"4255d2f3385db7cb9bd3316f8b415eebde1e7dae","modified":1547517169000},{"_id":"themes/material-x/layout/_third-party/aplayer.ejs","hash":"0c2fad2d831ac96a6ddbe37e79771741cefd258e","modified":1547517169000},{"_id":"themes/material-x/layout/_third-party/recommended_posts.ejs","hash":"f18eba4ba379e0fbb4ac435cc7cd8adb74519ecd","modified":1547517169000},{"_id":"themes/material-x/layout/_third-party/comments.ejs","hash":"b134f2b4bb6cb919af3182364e7550414b8dfd4e","modified":1547517169000},{"_id":"themes/material-x/layout/_third-party/share.ejs","hash":"80d700c5d3e806ec73227517b1f02d38801c81ab","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/author.ejs","hash":"7fc6257bc723b572dd86b84aa0e240cceeaf11c7","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/header.ejs","hash":"a9b2ae0de87e3b5384d89eca0d8a9c9c11b40315","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/category.ejs","hash":"3fc4b6b18854f70cc0625e0b90bc1bf5383053b5","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/list.ejs","hash":"a7a51f4d8b3ab19bcc37e2227a6739fdd7955c02","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/music.ejs","hash":"0775ddc5c9b257e26f75054a2a232183b5bd260d","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/plain.ejs","hash":"2f9febe43990af3520e520ee6fba94758c229322","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/tagcloud.ejs","hash":"ec791945c3dd4cf3006ca9ab8865e56d05355d13","modified":1547517169000},{"_id":"themes/material-x/layout/_widget/toc.ejs","hash":"711b9a669598f358910b92c853afe268cda9b0cf","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/LICENSE.txt","hash":"9907c55306fffb685ce0e06c9e469475035d5fa6","modified":1547517169000},{"_id":"themes/material-x/source/fonts/Monaco.ttf","hash":"d4de9305ce9e916ece179c3ab3b1faf80cc52bbb","modified":1547517169000},{"_id":"themes/material-x/source/js/app.js","hash":"9e776b6cda6d3de66ffb45e32cd4f11b5932497b","modified":1547517169000},{"_id":"themes/material-x/source/js/search.js","hash":"b03a1fcd19c4189d1b490b5b284ee5625d884ce6","modified":1547517169000},{"_id":"themes/material-x/source/less/_archive.less","hash":"38e38dc3b1b054ab02ad9adf3bbf869c13d23cfd","modified":1547517169000},{"_id":"themes/material-x/source/less/_article.less","hash":"4bba9a74ff8175d1eb79de21dfa45e9d75b07043","modified":1547517169000},{"_id":"themes/material-x/source/less/_base.less","hash":"0f296964f5e66213a0a777b61560cfb90a94ac31","modified":1547517169000},{"_id":"themes/material-x/source/less/_defines.less","hash":"59912db57e6051debd70487848501e6ad0a016ed","modified":1547517169000},{"_id":"themes/material-x/source/less/_color.less","hash":"5a13b755eca759499ad9c660029f13157ff21f0f","modified":1547517169000},{"_id":"themes/material-x/source/less/_fonts.less","hash":"72f402857faee1efea13efa3c90ac23a073a020a","modified":1547517169000},{"_id":"themes/material-x/source/less/_footer.less","hash":"10b3572af258f9ceb4aded7df5deb29a8416caa1","modified":1547517169000},{"_id":"themes/material-x/source/less/_layout.less","hash":"c1a567707980e827d1fe492efa0ce39a3f6b6b8d","modified":1547517169000},{"_id":"themes/material-x/source/less/_header.less","hash":"04e3b95489f8c2db8ea682247482eab519b07466","modified":1547517169000},{"_id":"themes/material-x/source/less/_links.less","hash":"19a2e3e4321665d6e9a2817f476d1f3bdac9c632","modified":1547517169000},{"_id":"themes/material-x/source/less/_main.less","hash":"7cb6befdbdcda98bcfe69802436d47830a79ddcf","modified":1547517169000},{"_id":"themes/material-x/source/less/_normalize.less","hash":"11fec4d4fcc168d91c940796e42f6d7e3b618163","modified":1547517169000},{"_id":"themes/material-x/source/less/_pagination.less","hash":"165e2c369faf70858b731bb6d483d8991259887e","modified":1547517169000},{"_id":"themes/material-x/source/less/_search.less","hash":"b8e563594df0da363ab10bead56f5a27e442d877","modified":1547517169000},{"_id":"themes/material-x/source/less/_side.less","hash":"f4bb5894d3db17244fec48a7396bb9ed7e42fad8","modified":1547517169000},{"_id":"themes/material-x/source/less/_toc.less","hash":"f5467aff70e432f506425fab3eb7cf6f3373e43d","modified":1547517169000},{"_id":"themes/material-x/source/less/_tog.less","hash":"73e72c4efd04a8721a87002de1a8a0201e1f5564","modified":1547517169000},{"_id":"themes/material-x/source/less/_typo.less","hash":"6a93f9fab3e1dfac4dc80dd77bf6b1223b5fb058","modified":1547517169000},{"_id":"themes/material-x/source/less/_widget.less","hash":"114fb24969f766cce5b57f635167ddb5188f1e0c","modified":1547517169000},{"_id":"themes/material-x/source/js/volantis.js","hash":"a916f26f3be818d8e4a0514a3ced3d9c0a0e326f","modified":1547517169000},{"_id":"themes/material-x/.git/refs/heads/master","hash":"c035a8aeb83734d4ec598d009c34d3d31d0bf0d7","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/all.min.css","hash":"07013bc45af8f3412ea2d15b874702aeb1df3350","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/brands.css","hash":"8fbe246a8db12cfbeb0d4eab0b3e25c1fc6d49fb","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/brands.min.css","hash":"09472b303e13bff78f04552fdade03f802569641","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/fontawesome.min.css","hash":"5d39196b3b30d4bcd0dad8f67e4b55209c3c32fd","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/regular.css","hash":"c42d1af63ec148d83d00dd160f1850cb1477d86f","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/regular.min.css","hash":"cc65417f088603265982b57e50af7ef2943fcb0a","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/solid.css","hash":"061802d2a4e6a0b9bb966306258a32256fa3c073","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/solid.min.css","hash":"f09c78ed7531816902ff18a0a834ead28c4cc593","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/svg-with-js.css","hash":"4c0f2f0d3d26c7a129362a4bc87ac4daab012497","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/svg-with-js.min.css","hash":"d44497c65147b71d08363e483d4ff63842934e84","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/v4-shims.css","hash":"37f6b00db1fa35bda0069b7f45d9f2a9aaee4d90","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/v4-shims.min.css","hash":"271a73480565cd495f819a393ef0b1e0653eb2bd","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.eot","hash":"b55b6e468adfb5d52879ba9389cad2a2b97892c9","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.woff","hash":"26b552cb139041d3044c937e7879c9be2a8528bf","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.ttf","hash":"3d58fd9d329aad13e48c4cbb0620cd47d583c047","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.woff2","hash":"a4c23e5bae96a5da2dba5599d56114faeb4a3495","modified":1547517169000},{"_id":"themes/material-x/.git/objects/pack/pack-d719e68654e47bcdeac0b1be045b43b2635a1a4d.idx","hash":"c2c355a31a6bf3d32360c0dda9f1570faff6f489","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/all.css","hash":"09705c19d9653fdee7cae8e6e65ecf1c50d9bf1e","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/css/fontawesome.css","hash":"bf8b952555e2eb60aa167066fe30ae03de66361b","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.woff","hash":"e00a59950b59ba51e1bd1bce08d2f63d03a2268a","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.woff2","hash":"0039be9d8a99d1e5cf200ca3e08757692020460e","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.woff","hash":"28b3d94d115d3e80c3ffd86239fd84638c88d463","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.woff2","hash":"28a1f2fadc35c5343e0280389fe7955e3d1be607","modified":1547517169000},{"_id":"themes/material-x/source/fonts/Skranji-Regular.ttf","hash":"485dc033e34a5a92a45ffe5839514f0471b18208","modified":1547517169000},{"_id":"themes/material-x/.git/logs/refs/heads/master","hash":"df59aa8b04e9b5453fc872c97bdb8128020b9f50","modified":1547517169000},{"_id":"themes/material-x/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.eot","hash":"5958a06de280ca88fd431cb53f99816b29f91aea","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.ttf","hash":"7cba2133893eb41e742d630f1218a8ac151675c8","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-regular-400.svg","hash":"b8a1e30d9a065d11224b351430df8c91dcd87a28","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.eot","hash":"600b88c2053af11c6c7ea0491ff2554fda79ecbb","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.ttf","hash":"4f8bfab573ad1de9084b1f7675953e2008e3f459","modified":1547517169000},{"_id":"themes/material-x/source/fonts/Ubuntu-Regular.ttf","hash":"b100b2ed912a91e4d0a7c5f5309fe8ad7b3a2dd8","modified":1547517169000},{"_id":"themes/material-x/.git/logs/refs/remotes/origin/HEAD","hash":"df59aa8b04e9b5453fc872c97bdb8128020b9f50","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-brands-400.svg","hash":"c273f11db822bf4acf4a4d1f008e5c2415a1237b","modified":1547517169000},{"_id":"themes/material-x/source/fontawesome-free-5.6.3-web/webfonts/fa-solid-900.svg","hash":"89c3ffa215f239f9eb37e2d0f11935b9da01a3ac","modified":1547517169000},{"_id":"themes/material-x/.git/objects/pack/pack-d719e68654e47bcdeac0b1be045b43b2635a1a4d.pack","hash":"b733aa199afd20f82ab0f3ca071b3d8fcb8112a5","modified":1547517169000},{"_id":"themes/material-x/.git/FETCH_HEAD","hash":"4a0807bc3e6f401cc60dedde0f501ee3dd069c67","modified":1548814617000},{"_id":"themes/material-x/.git/ORIG_HEAD","hash":"c035a8aeb83734d4ec598d009c34d3d31d0bf0d7","modified":1548814617000},{"_id":"themes/material-x/.git/objects/03/4805fc0139b2185206e5f3f9b5749bb4b0e014","hash":"e8629755f3b757e610c143e0b96e56b4781e03c3","modified":1548814617000},{"_id":"themes/material-x/.git/objects/0b/f49aeee4ebbdf6834a110758e32a19b41f8f82","hash":"8abc1dbaa271f326739f023639890730eb764c16","modified":1548814617000},{"_id":"themes/material-x/.git/objects/0c/f1e8c83da3f3568dea7065ff779b5b8db62106","hash":"5f8c60d8d6144f419dc821053bd1df48458d278a","modified":1548814617000},{"_id":"themes/material-x/.git/objects/25/fdeb7c4ce92aa4eaa17bf9d65f37346b64b327","hash":"56d2de4327de78fefdeeb5f3eca8a51d83a4e662","modified":1548814617000},{"_id":"themes/material-x/.git/objects/2b/16b7691d3556c021b5bf5e45c5be14453774cf","hash":"d40ba592e51c62ea8a7923f780239b42417fb605","modified":1548814617000},{"_id":"themes/material-x/.git/objects/33/4801fa5e13d57e9913f01be4f11b63a8fcd4d7","hash":"acc7dc105fc34c5667c1ce693646dd0e18efcf62","modified":1548814617000},{"_id":"themes/material-x/.git/objects/33/4c2d4bc20eb1ef180e097d8d0296ec8e021e20","hash":"341aac2174f724e40250d6cc128336de2c9c3a40","modified":1548814617000},{"_id":"themes/material-x/.git/objects/4b/1ace1d5296998e1f18d60a5f46d03c3225afdf","hash":"dbc8c46fd2d739ec6c917902f0c0ae465b2bc75b","modified":1548814617000},{"_id":"themes/material-x/.git/objects/4b/e786f675e2fe8f151b34145100da75afa127bb","hash":"63765fcbbfbefde6609d921b9b622fc3b9b321eb","modified":1548814617000},{"_id":"themes/material-x/.git/objects/64/6fee841ffc2ef4638583dd9a0c9c6727d7859a","hash":"073955cdd96043d9c2391b7f72cb7f6ad9557655","modified":1548814617000},{"_id":"themes/material-x/.git/objects/68/7bd2ccb29d833e81df8b7542e98bc2f3b31adb","hash":"f1c8ca0cb66ce071939fc455763628b643a11487","modified":1548814617000},{"_id":"themes/material-x/.git/objects/6f/55b93cb157c82b17a9c449029239e54ade2583","hash":"ca909920ece05088eb0014468bf52d2077db3841","modified":1548814617000},{"_id":"themes/material-x/.git/objects/77/aae591262293afdfba107a7a93c2ab4c3eed5c","hash":"5ca21a2b52dc96ee800c3410d020e2e132a8d3d1","modified":1548814617000},{"_id":"themes/material-x/.git/objects/78/1900fb186c1727bcf4a5c9f23ebf4f5d421f2e","hash":"181287f137c3dd7e9225139a657cb78e09109d5f","modified":1548814617000},{"_id":"themes/material-x/.git/objects/85/0b4aee6caa4f593117cfe134b3a5431bb769d3","hash":"f1218c1c5b13e57288f9c98b1cfad508ca998de7","modified":1548814617000},{"_id":"themes/material-x/.git/objects/8e/4efdac35f1f9ec035930c7e57a1977ee111f1e","hash":"519f31b298079500c769637772b603a520485018","modified":1548814617000},{"_id":"themes/material-x/.git/objects/8e/be97669eea31685deeb2c303b82e78550be695","hash":"69c492bcf651f9c2bbb876fe728ad7f709d7c009","modified":1548814617000},{"_id":"themes/material-x/.git/objects/92/90b5699204c5b59f1b14e0b69b7a2007f78421","hash":"22ebc8d307c57971a1272e45bb2f3095cb715dd1","modified":1548814617000},{"_id":"themes/material-x/.git/objects/96/b0928228966c115209bd44cbc99249aa07595c","hash":"a305ba2cf33fe7b07f5f824dca9255a0b90ab697","modified":1548814617000},{"_id":"themes/material-x/.git/objects/a2/bb2a3e14d964237a04c521e40a468a3ff0671a","hash":"9b20b3451f7d24c6589b635166d861b8b60e80fa","modified":1548814617000},{"_id":"themes/material-x/.git/objects/a3/3c4f00fec5d21c81bfd4a44bf1068f76b2bb2c","hash":"1d3118e9b383e1cc72d5e8fea731d429079135a5","modified":1548814617000},{"_id":"themes/material-x/.git/objects/a5/691d745c19a97ecf6d8e92aee94202006acb25","hash":"a56ef78c1822d6184d38e717fa92d3c73c53b890","modified":1548814617000},{"_id":"themes/material-x/.git/objects/a7/41e802545dd3f640785fb5c62ffa1fde121b5e","hash":"6a93c1e29962dcc2c89bbabc94ef92e0edc77360","modified":1548814617000},{"_id":"themes/material-x/.git/objects/aa/2425b071279aeedf560041d51694286d98209c","hash":"53c317844ac677535bed8b7bc869c3c41b0fa140","modified":1548814617000},{"_id":"themes/material-x/.git/objects/af/94c061cdfbb7c62080eb9604b3d87ca6a1e08c","hash":"f27b1fb99df2be0c2e9fe794911cd9668bc83402","modified":1548814617000},{"_id":"themes/material-x/.git/objects/b4/27ec181c36f61efbbaff3e0a53d5abe6069bec","hash":"a1f311708afa9230c78e2945f9bfd7e56f6a7514","modified":1548814617000},{"_id":"themes/material-x/.git/objects/b5/25ecf364a81ceaea8855265d1829f31bbedb10","hash":"3795693eb5cd19375b5c435e2fd81c63b5c8d24e","modified":1548814617000},{"_id":"themes/material-x/.git/objects/c1/f727572949ebef021902bc2ce8ca5dca554778","hash":"d189a0c32fd4175aed0284f8cdd62cb7b2b98bc7","modified":1548814617000},{"_id":"themes/material-x/.git/objects/c5/12a21f782fc601b28fb9571e78d04755383775","hash":"2283b06dd14c775907f53ebe43080eb658f19d2f","modified":1548814617000},{"_id":"themes/material-x/.git/objects/d0/1ae95815b4d3c85488c13ba5801fac81dfa9b2","hash":"9b1cda47c8dcfeb748645a45a864cc2fa96e9079","modified":1548814617000},{"_id":"themes/material-x/.git/objects/d4/7b6c21a63a9cca3c305d76e2a8b67ef768313e","hash":"458089b9947e3ab4186c97276c10c2f43dbb6a88","modified":1548814617000},{"_id":"themes/material-x/.git/objects/d7/932b9e7c78f51f514f02b009a8d5b37ae2e336","hash":"948155f136800835b7409ef16d1a9869fcbbb63a","modified":1548814617000},{"_id":"themes/material-x/.git/objects/de/560619337bccf4ff748c2436e782289f620b4b","hash":"03b3aa2de3a013212325d146b395c39f43beb5a5","modified":1548814617000},{"_id":"themes/material-x/.git/objects/e3/4326eee1b52c87acf93b5254bc2da509b822f6","hash":"61ad4956b6217a25831b07d6c9c392b61c7be21b","modified":1548814617000},{"_id":"themes/material-x/.git/objects/e9/7aaf6054f154a440dffbe41680d969a9deda56","hash":"0d6b21b09092a2e5af15cf1e3f95aacd1f177f81","modified":1548814617000},{"_id":"themes/material-x/.git/objects/f8/38d35fa819808fa54154688a07fe7452c6952c","hash":"94eacf43430e28aabd8cdcd7c28f60c23313be3b","modified":1548814617000},{"_id":"themes/material-x/.git/refs/tags/1.0.5","hash":"dcbe40a08900bd1c0c3dab20d85b4d46690931f8","modified":1548814617000},{"_id":"themes/material-x/.git/refs/remotes/origin/master","hash":"dcbe40a08900bd1c0c3dab20d85b4d46690931f8","modified":1548814617000},{"_id":"themes/material-x/.git/logs/refs/remotes/origin/master","hash":"258978ad58fb7228a54e0217244eee74e4421b11","modified":1548814617000},{"_id":"source/_posts/call和apply.md","hash":"afed6bf49bbd12237dbd82cb7a4817cfc3268bd5","modified":1548816882000},{"_id":"source/_posts/javascript性能优化.md","hash":"6bde98d895b2609ba19105b8eb7411a2330e2878","modified":1548817908000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"css 代码规范","date":"2017-01-07T05:26:40.000Z","_content":"* 所有的十六进制值都应该使用小写字母，例如 #fff\n* 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。\n* 为选择器中得属性取值添加引号，例如 input[type=\"text\"]\n* 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;\n\n<!-- more -->\n\n* 4 个空格\n* 在每个声明的左括号前增加一个空格，声明块的右括号应该另起一行：  \n```\n.selector {\n    color:#fff;\n }\n ```\n* 所有的十六进制值都应该使用小写字母，例如 #fff\n* 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。\n* 为选择器中得属性取值添加引号，例如 input[type=\"text\"]\n* 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;\n\n* 相关的属性声明应该以下面的顺序分组处理（渲染效率）\n  - Positioning 定位\n  - Box model 盒模型\n  - Typographic 排版\n  - Visual 外观\n  \n  ```\n  /* Positioning 定位 */ \n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 100;\n\n  /* Box-model 盒模型*/\n  display: block;\n  float: right;\n  width: 100px;\n  height: 100px;\n\n  /* Typography 排版*/\n  font: normal 13px \"Helvetica Neue\", sans-serif;\n  line-height: 1.5;\n  color: #333;\n  text-align: center;\n\n  /* Visual 外观*/\n  background-color: #f5f5f5;\n  border: 1px solid #e5e5e5;\n  border-radius: 3px;\n\n  /* Misc */\n  opacity: 1;\n  ```\n* 媒体查询位置 靠近他们相关的规则\n* 不要使用 @import : 与 link 相比, @import 更慢，需要额外的页面请求，并且可能引发其他的意想不到的问题。\n\n* 前缀属性: 当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑\n```\n.selector {\n  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);\n          box-shadow: 0 1px 2px rgba(0,0,0,.15);\n}\n```\n\n* 在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。\n\n* 坚持限制属性取值简写的使用，属性简写需要你必须显式设置所有取值\n```\n/* Good example */\n.element {\n  margin-bottom: 10px;\n  background-color: red;\n  background-image: url(\"image.jpg\");\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n}\n```\n\n* Class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）\n* Class 的命名应该尽量短，也要尽量明确,最多三个：.top-title-p\n* 以组件为单位组织代码\n* 使用一致的空白来分割代码块\n\n* 编辑器配置\n  -使用 4 个空格的 soft-tabs\n  - 在保存时删除尾部的空白字符\n  - 设置文件编码为 UTF-8\n  - 在文件结尾添加一个空白行\n\n\n阮一峰新增 css 教程：https://github.com/wangdoc/css-tutorial/tree/master/docs","source":"_posts/3.0 css 代码规范.md","raw":"---\ntitle: css 代码规范\ndate: 2017-01-07 13:26:40\ntags:\n---\n* 所有的十六进制值都应该使用小写字母，例如 #fff\n* 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。\n* 为选择器中得属性取值添加引号，例如 input[type=\"text\"]\n* 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;\n\n<!-- more -->\n\n* 4 个空格\n* 在每个声明的左括号前增加一个空格，声明块的右括号应该另起一行：  \n```\n.selector {\n    color:#fff;\n }\n ```\n* 所有的十六进制值都应该使用小写字母，例如 #fff\n* 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。\n* 为选择器中得属性取值添加引号，例如 input[type=\"text\"]\n* 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;\n\n* 相关的属性声明应该以下面的顺序分组处理（渲染效率）\n  - Positioning 定位\n  - Box model 盒模型\n  - Typographic 排版\n  - Visual 外观\n  \n  ```\n  /* Positioning 定位 */ \n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 100;\n\n  /* Box-model 盒模型*/\n  display: block;\n  float: right;\n  width: 100px;\n  height: 100px;\n\n  /* Typography 排版*/\n  font: normal 13px \"Helvetica Neue\", sans-serif;\n  line-height: 1.5;\n  color: #333;\n  text-align: center;\n\n  /* Visual 外观*/\n  background-color: #f5f5f5;\n  border: 1px solid #e5e5e5;\n  border-radius: 3px;\n\n  /* Misc */\n  opacity: 1;\n  ```\n* 媒体查询位置 靠近他们相关的规则\n* 不要使用 @import : 与 link 相比, @import 更慢，需要额外的页面请求，并且可能引发其他的意想不到的问题。\n\n* 前缀属性: 当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑\n```\n.selector {\n  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);\n          box-shadow: 0 1px 2px rgba(0,0,0,.15);\n}\n```\n\n* 在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。\n\n* 坚持限制属性取值简写的使用，属性简写需要你必须显式设置所有取值\n```\n/* Good example */\n.element {\n  margin-bottom: 10px;\n  background-color: red;\n  background-image: url(\"image.jpg\");\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n}\n```\n\n* Class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）\n* Class 的命名应该尽量短，也要尽量明确,最多三个：.top-title-p\n* 以组件为单位组织代码\n* 使用一致的空白来分割代码块\n\n* 编辑器配置\n  -使用 4 个空格的 soft-tabs\n  - 在保存时删除尾部的空白字符\n  - 设置文件编码为 UTF-8\n  - 在文件结尾添加一个空白行\n\n\n阮一峰新增 css 教程：https://github.com/wangdoc/css-tutorial/tree/master/docs","slug":"3.0 css 代码规范","published":1,"updated":"2019-01-15T06:42:07.000Z","_id":"cjqx4he6y0000yqnxvi4xtep8","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>所有的十六进制值都应该使用小写字母，例如 #fff</li>\n<li>尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。</li>\n<li>为选择器中得属性取值添加引号，例如 input[type=”text”]</li>\n<li>不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>4 个空格</li>\n<li><p>在每个声明的左括号前增加一个空格，声明块的右括号应该另起一行：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.selector &#123;</span><br><span class=\"line\">    color:#fff;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所有的十六进制值都应该使用小写字母，例如 #fff</p>\n</li>\n<li>尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。</li>\n<li>为选择器中得属性取值添加引号，例如 input[type=”text”]</li>\n<li><p>不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;</p>\n</li>\n<li><p>相关的属性声明应该以下面的顺序分组处理（渲染效率）</p>\n<ul>\n<li>Positioning 定位</li>\n<li>Box model 盒模型</li>\n<li>Typographic 排版</li>\n<li>Visual 外观</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Positioning 定位 */ </span><br><span class=\"line\">position: absolute;</span><br><span class=\"line\">top: 0;</span><br><span class=\"line\">right: 0;</span><br><span class=\"line\">bottom: 0;</span><br><span class=\"line\">left: 0;</span><br><span class=\"line\">z-index: 100;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Box-model 盒模型*/</span><br><span class=\"line\">display: block;</span><br><span class=\"line\">float: right;</span><br><span class=\"line\">width: 100px;</span><br><span class=\"line\">height: 100px;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Typography 排版*/</span><br><span class=\"line\">font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;</span><br><span class=\"line\">line-height: 1.5;</span><br><span class=\"line\">color: #333;</span><br><span class=\"line\">text-align: center;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Visual 外观*/</span><br><span class=\"line\">background-color: #f5f5f5;</span><br><span class=\"line\">border: 1px solid #e5e5e5;</span><br><span class=\"line\">border-radius: 3px;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Misc */</span><br><span class=\"line\">opacity: 1;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>媒体查询位置 靠近他们相关的规则</p>\n</li>\n<li><p>不要使用 @import : 与 link 相比, @import 更慢，需要额外的页面请求，并且可能引发其他的意想不到的问题。</p>\n</li>\n<li><p>前缀属性: 当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.selector &#123;</span><br><span class=\"line\">  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);</span><br><span class=\"line\">          box-shadow: 0 1px 2px rgba(0,0,0,.15);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。</p>\n</li>\n<li><p>坚持限制属性取值简写的使用，属性简写需要你必须显式设置所有取值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Good example */</span><br><span class=\"line\">.element &#123;</span><br><span class=\"line\">  margin-bottom: 10px;</span><br><span class=\"line\">  background-color: red;</span><br><span class=\"line\">  background-image: url(&quot;image.jpg&quot;);</span><br><span class=\"line\">  border-top-left-radius: 3px;</span><br><span class=\"line\">  border-top-right-radius: 3px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）</p>\n</li>\n<li>Class 的命名应该尽量短，也要尽量明确,最多三个：.top-title-p</li>\n<li>以组件为单位组织代码</li>\n<li><p>使用一致的空白来分割代码块</p>\n</li>\n<li><p>编辑器配置<br>-使用 4 个空格的 soft-tabs</p>\n<ul>\n<li>在保存时删除尾部的空白字符</li>\n<li>设置文件编码为 UTF-8</li>\n<li>在文件结尾添加一个空白行</li>\n</ul>\n</li>\n</ul>\n<p>阮一峰新增 css 教程：<a href=\"https://github.com/wangdoc/css-tutorial/tree/master/docs\" target=\"_blank\" rel=\"noopener\">https://github.com/wangdoc/css-tutorial/tree/master/docs</a></p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>所有的十六进制值都应该使用小写字母，例如 #fff</li>\n<li>尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。</li>\n<li>为选择器中得属性取值添加引号，例如 input[type=”text”]</li>\n<li>不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;</li>\n</ul>","more":"<ul>\n<li>4 个空格</li>\n<li><p>在每个声明的左括号前增加一个空格，声明块的右括号应该另起一行：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.selector &#123;</span><br><span class=\"line\">    color:#fff;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所有的十六进制值都应该使用小写字母，例如 #fff</p>\n</li>\n<li>尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。</li>\n<li>为选择器中得属性取值添加引号，例如 input[type=”text”]</li>\n<li><p>不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;</p>\n</li>\n<li><p>相关的属性声明应该以下面的顺序分组处理（渲染效率）</p>\n<ul>\n<li>Positioning 定位</li>\n<li>Box model 盒模型</li>\n<li>Typographic 排版</li>\n<li>Visual 外观</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Positioning 定位 */ </span><br><span class=\"line\">position: absolute;</span><br><span class=\"line\">top: 0;</span><br><span class=\"line\">right: 0;</span><br><span class=\"line\">bottom: 0;</span><br><span class=\"line\">left: 0;</span><br><span class=\"line\">z-index: 100;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Box-model 盒模型*/</span><br><span class=\"line\">display: block;</span><br><span class=\"line\">float: right;</span><br><span class=\"line\">width: 100px;</span><br><span class=\"line\">height: 100px;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Typography 排版*/</span><br><span class=\"line\">font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;</span><br><span class=\"line\">line-height: 1.5;</span><br><span class=\"line\">color: #333;</span><br><span class=\"line\">text-align: center;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Visual 外观*/</span><br><span class=\"line\">background-color: #f5f5f5;</span><br><span class=\"line\">border: 1px solid #e5e5e5;</span><br><span class=\"line\">border-radius: 3px;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Misc */</span><br><span class=\"line\">opacity: 1;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>媒体查询位置 靠近他们相关的规则</p>\n</li>\n<li><p>不要使用 @import : 与 link 相比, @import 更慢，需要额外的页面请求，并且可能引发其他的意想不到的问题。</p>\n</li>\n<li><p>前缀属性: 当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.selector &#123;</span><br><span class=\"line\">  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);</span><br><span class=\"line\">          box-shadow: 0 1px 2px rgba(0,0,0,.15);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。</p>\n</li>\n<li><p>坚持限制属性取值简写的使用，属性简写需要你必须显式设置所有取值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Good example */</span><br><span class=\"line\">.element &#123;</span><br><span class=\"line\">  margin-bottom: 10px;</span><br><span class=\"line\">  background-color: red;</span><br><span class=\"line\">  background-image: url(&quot;image.jpg&quot;);</span><br><span class=\"line\">  border-top-left-radius: 3px;</span><br><span class=\"line\">  border-top-right-radius: 3px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）</p>\n</li>\n<li>Class 的命名应该尽量短，也要尽量明确,最多三个：.top-title-p</li>\n<li>以组件为单位组织代码</li>\n<li><p>使用一致的空白来分割代码块</p>\n</li>\n<li><p>编辑器配置<br>-使用 4 个空格的 soft-tabs</p>\n<ul>\n<li>在保存时删除尾部的空白字符</li>\n<li>设置文件编码为 UTF-8</li>\n<li>在文件结尾添加一个空白行</li>\n</ul>\n</li>\n</ul>\n<p>阮一峰新增 css 教程：<a href=\"https://github.com/wangdoc/css-tutorial/tree/master/docs\" target=\"_blank\" rel=\"noopener\">https://github.com/wangdoc/css-tutorial/tree/master/docs</a></p>"},{"title":"解决各种IE兼容","date":"2017-01-03T02:09:21.000Z","_content":"可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。\n\n<!-- more -->\n\n```\nGoogle Chrome Frame也可以让IE用上Chrome的引擎:\n\n<meta http-equiv=“X-UA-Compatible” content=“chrome=1″ />\n\n<meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″ />\n创建html5时发现这么一句话，百度如下：\n这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果没安装GCF，则使用最高版本的IE内核进行渲染。\nGoogle Chrome Frame（谷歌内嵌浏览器框架GCF）。\n可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。\n```\n\n","source":"_posts/解决各种IE兼容.md","raw":"---\ntitle: 解决各种IE兼容\ndate: 2017-01-03 10:09:21\ntags:\n---\n可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。\n\n<!-- more -->\n\n```\nGoogle Chrome Frame也可以让IE用上Chrome的引擎:\n\n<meta http-equiv=“X-UA-Compatible” content=“chrome=1″ />\n\n<meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″ />\n创建html5时发现这么一句话，百度如下：\n这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果没安装GCF，则使用最高版本的IE内核进行渲染。\nGoogle Chrome Frame（谷歌内嵌浏览器框架GCF）。\n可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。\n```\n\n","slug":"解决各种IE兼容","published":1,"updated":"2019-01-15T06:40:54.000Z","_id":"cjqx4he750002yqnx6bfuzdpo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Google Chrome Frame也可以让IE用上Chrome的引擎:</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;meta http-equiv=“X-UA-Compatible” content=“chrome=1″ /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″ /&gt;</span><br><span class=\"line\">创建html5时发现这么一句话，百度如下：</span><br><span class=\"line\">这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果没安装GCF，则使用最高版本的IE内核进行渲染。</span><br><span class=\"line\">Google Chrome Frame（谷歌内嵌浏览器框架GCF）。</span><br><span class=\"line\">可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Google Chrome Frame也可以让IE用上Chrome的引擎:</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;meta http-equiv=“X-UA-Compatible” content=“chrome=1″ /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″ /&gt;</span><br><span class=\"line\">创建html5时发现这么一句话，百度如下：</span><br><span class=\"line\">这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果没安装GCF，则使用最高版本的IE内核进行渲染。</span><br><span class=\"line\">Google Chrome Frame（谷歌内嵌浏览器框架GCF）。</span><br><span class=\"line\">可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。</span><br></pre></td></tr></table></figure>"},{"title":"call 和 apply","date":"2017-01-24T10:13:20.000Z","_content":"call和apply的区别\n\n<!-- more -->\n\n# 调用一个对象的一个方法，以另一个对象替换当前对象\n\napply(func,数组参数)：\n\n```\nfunction add(a,b){\n  return a+b;  \n}\nfunction sub(a,b){\n  return a-b;  \n}\nvar a1 = add.apply(sub,[4,2]);　　//sub调用add的方法\nvar a2 = sub.apply(add,[4,2]);\nalert(a1);  //6     \nalert(a2);  //2\n```\n\n\n\n## 模拟实现\n```\nFunction.prototype.newCall = function(context) {\n  context.fn = this;  // 通过this获取call的函数\n  context.fn();\n  delete context.fn;\n}\nlet foo = {\n  value: 1\n}\nfunction bar() {\n  console.log(this.value);\n}\nbar.newCall (foo); // 1\n```\n\n>但是如果说有传参数呢？  \n所以我们可以进行优化一下，因为传入的参数数量是不确定的，所以我们可以从Arguments对象中去获取，这个比较简单。  \n问题是参数是不确定的，我们如何传入到我们要执行的函数中去呢 ？ 这里我们有两种选择：一种是通过eval拼接的方式，另一种就要用到es6了。\n\n```\nFunction.prototype.newCall = function(context, ...parameter) {\n  if (typeof context === 'object') {\n    context = context || window\n  } else {\n    context = Object.create(null)\n  }\n  let fn = Symbol()\n  context[fn] = this\n  context[fn](...parameter);\n  delete context[fn]\n}\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age,sex) {\n  console.log(this.name, age, sex);\n}\nsayHi.newCall (person, 25, '男'); // Abiel 25 \n\n```\n\n实现了call之后，apply也是同样的思路。\n\n===========================================\n\n## apply实现：\n```\nFunction.prototype.newApply = function(context, parameter) {\n  if (typeof context === 'object') {\n    context = context || window\n  } else {\n    context = Object.create(null)\n  }\n  let fn = Symbol()\n  context[fn] = this\n  context[fn](...parameter);\n  delete context[fn]\n}\n\n```\n## bind\n初体验：\n\n\n```\nFunction.prototype.bind = function (context) {\n  var me = this\n  return function () { // bind之后得到的函数\n    return me.call(context)  // 执行是改变this执行\n  }\n}\n\n\n加入参数：\n\nFunction.prototype.bind = function (context,...innerArgs) {\n  var me = this\n  return function (...finnalyArgs) {\n    return me.call(context,...innerArgs,...finnalyArgs)\n  }\n}\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age,sex) {\n  console.log(this.name, age, sex);\n}\nlet personSayHi = sayHi.bind(person, 25)\npersonSayHi('男')\n```\n","source":"_posts/call和apply.md","raw":"---\ntitle: call 和 apply\ndate: 2017-01-24 18:13:20\ntags:\n---\ncall和apply的区别\n\n<!-- more -->\n\n# 调用一个对象的一个方法，以另一个对象替换当前对象\n\napply(func,数组参数)：\n\n```\nfunction add(a,b){\n  return a+b;  \n}\nfunction sub(a,b){\n  return a-b;  \n}\nvar a1 = add.apply(sub,[4,2]);　　//sub调用add的方法\nvar a2 = sub.apply(add,[4,2]);\nalert(a1);  //6     \nalert(a2);  //2\n```\n\n\n\n## 模拟实现\n```\nFunction.prototype.newCall = function(context) {\n  context.fn = this;  // 通过this获取call的函数\n  context.fn();\n  delete context.fn;\n}\nlet foo = {\n  value: 1\n}\nfunction bar() {\n  console.log(this.value);\n}\nbar.newCall (foo); // 1\n```\n\n>但是如果说有传参数呢？  \n所以我们可以进行优化一下，因为传入的参数数量是不确定的，所以我们可以从Arguments对象中去获取，这个比较简单。  \n问题是参数是不确定的，我们如何传入到我们要执行的函数中去呢 ？ 这里我们有两种选择：一种是通过eval拼接的方式，另一种就要用到es6了。\n\n```\nFunction.prototype.newCall = function(context, ...parameter) {\n  if (typeof context === 'object') {\n    context = context || window\n  } else {\n    context = Object.create(null)\n  }\n  let fn = Symbol()\n  context[fn] = this\n  context[fn](...parameter);\n  delete context[fn]\n}\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age,sex) {\n  console.log(this.name, age, sex);\n}\nsayHi.newCall (person, 25, '男'); // Abiel 25 \n\n```\n\n实现了call之后，apply也是同样的思路。\n\n===========================================\n\n## apply实现：\n```\nFunction.prototype.newApply = function(context, parameter) {\n  if (typeof context === 'object') {\n    context = context || window\n  } else {\n    context = Object.create(null)\n  }\n  let fn = Symbol()\n  context[fn] = this\n  context[fn](...parameter);\n  delete context[fn]\n}\n\n```\n## bind\n初体验：\n\n\n```\nFunction.prototype.bind = function (context) {\n  var me = this\n  return function () { // bind之后得到的函数\n    return me.call(context)  // 执行是改变this执行\n  }\n}\n\n\n加入参数：\n\nFunction.prototype.bind = function (context,...innerArgs) {\n  var me = this\n  return function (...finnalyArgs) {\n    return me.call(context,...innerArgs,...finnalyArgs)\n  }\n}\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age,sex) {\n  console.log(this.name, age, sex);\n}\nlet personSayHi = sayHi.bind(person, 25)\npersonSayHi('男')\n```\n","slug":"call和apply","published":1,"updated":"2019-01-30T02:54:42.000Z","_id":"cjriliz6t0000vqnxjamvy0xr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>call和apply的区别</p>\n<a id=\"more\"></a>\n<h1 id=\"调用一个对象的一个方法，以另一个对象替换当前对象\"><a href=\"#调用一个对象的一个方法，以另一个对象替换当前对象\" class=\"headerlink\" title=\"调用一个对象的一个方法，以另一个对象替换当前对象\"></a>调用一个对象的一个方法，以另一个对象替换当前对象</h1><p>apply(func,数组参数)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(a,b)&#123;</span><br><span class=\"line\">  return a+b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sub(a,b)&#123;</span><br><span class=\"line\">  return a-b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = add.apply(sub,[4,2]);　　//sub调用add的方法</span><br><span class=\"line\">var a2 = sub.apply(add,[4,2]);</span><br><span class=\"line\">alert(a1);  //6     </span><br><span class=\"line\">alert(a2);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"模拟实现\"><a href=\"#模拟实现\" class=\"headerlink\" title=\"模拟实现\"></a>模拟实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newCall = function(context) &#123;</span><br><span class=\"line\">  context.fn = this;  // 通过this获取call的函数</span><br><span class=\"line\">  context.fn();</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let foo = &#123;</span><br><span class=\"line\">  value: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">  console.log(this.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar.newCall (foo); // 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>但是如果说有传参数呢？<br>所以我们可以进行优化一下，因为传入的参数数量是不确定的，所以我们可以从Arguments对象中去获取，这个比较简单。<br>问题是参数是不确定的，我们如何传入到我们要执行的函数中去呢 ？ 这里我们有两种选择：一种是通过eval拼接的方式，另一种就要用到es6了。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newCall = function(context, ...parameter) &#123;</span><br><span class=\"line\">  if (typeof context === &apos;object&apos;) &#123;</span><br><span class=\"line\">    context = context || window</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    context = Object.create(null)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let fn = Symbol()</span><br><span class=\"line\">  context[fn] = this</span><br><span class=\"line\">  context[fn](...parameter);</span><br><span class=\"line\">  delete context[fn]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">  name: &apos;Abiel&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sayHi(age,sex) &#123;</span><br><span class=\"line\">  console.log(this.name, age, sex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.newCall (person, 25, &apos;男&apos;); // Abiel 25</span><br></pre></td></tr></table></figure>\n<p>实现了call之后，apply也是同样的思路。</p>\n<p>===========================================</p>\n<h2 id=\"apply实现：\"><a href=\"#apply实现：\" class=\"headerlink\" title=\"apply实现：\"></a>apply实现：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newApply = function(context, parameter) &#123;</span><br><span class=\"line\">  if (typeof context === &apos;object&apos;) &#123;</span><br><span class=\"line\">    context = context || window</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    context = Object.create(null)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let fn = Symbol()</span><br><span class=\"line\">  context[fn] = this</span><br><span class=\"line\">  context[fn](...parameter);</span><br><span class=\"line\">  delete context[fn]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>初体验：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function (context) &#123;</span><br><span class=\"line\">  var me = this</span><br><span class=\"line\">  return function () &#123; // bind之后得到的函数</span><br><span class=\"line\">    return me.call(context)  // 执行是改变this执行</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">加入参数：</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.bind = function (context,...innerArgs) &#123;</span><br><span class=\"line\">  var me = this</span><br><span class=\"line\">  return function (...finnalyArgs) &#123;</span><br><span class=\"line\">    return me.call(context,...innerArgs,...finnalyArgs)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">  name: &apos;Abiel&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sayHi(age,sex) &#123;</span><br><span class=\"line\">  console.log(this.name, age, sex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let personSayHi = sayHi.bind(person, 25)</span><br><span class=\"line\">personSayHi(&apos;男&apos;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>call和apply的区别</p>","more":"<h1 id=\"调用一个对象的一个方法，以另一个对象替换当前对象\"><a href=\"#调用一个对象的一个方法，以另一个对象替换当前对象\" class=\"headerlink\" title=\"调用一个对象的一个方法，以另一个对象替换当前对象\"></a>调用一个对象的一个方法，以另一个对象替换当前对象</h1><p>apply(func,数组参数)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(a,b)&#123;</span><br><span class=\"line\">  return a+b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sub(a,b)&#123;</span><br><span class=\"line\">  return a-b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = add.apply(sub,[4,2]);　　//sub调用add的方法</span><br><span class=\"line\">var a2 = sub.apply(add,[4,2]);</span><br><span class=\"line\">alert(a1);  //6     </span><br><span class=\"line\">alert(a2);  //2</span><br></pre></td></tr></table></figure>\n<h2 id=\"模拟实现\"><a href=\"#模拟实现\" class=\"headerlink\" title=\"模拟实现\"></a>模拟实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newCall = function(context) &#123;</span><br><span class=\"line\">  context.fn = this;  // 通过this获取call的函数</span><br><span class=\"line\">  context.fn();</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let foo = &#123;</span><br><span class=\"line\">  value: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">  console.log(this.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar.newCall (foo); // 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>但是如果说有传参数呢？<br>所以我们可以进行优化一下，因为传入的参数数量是不确定的，所以我们可以从Arguments对象中去获取，这个比较简单。<br>问题是参数是不确定的，我们如何传入到我们要执行的函数中去呢 ？ 这里我们有两种选择：一种是通过eval拼接的方式，另一种就要用到es6了。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newCall = function(context, ...parameter) &#123;</span><br><span class=\"line\">  if (typeof context === &apos;object&apos;) &#123;</span><br><span class=\"line\">    context = context || window</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    context = Object.create(null)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let fn = Symbol()</span><br><span class=\"line\">  context[fn] = this</span><br><span class=\"line\">  context[fn](...parameter);</span><br><span class=\"line\">  delete context[fn]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">  name: &apos;Abiel&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sayHi(age,sex) &#123;</span><br><span class=\"line\">  console.log(this.name, age, sex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.newCall (person, 25, &apos;男&apos;); // Abiel 25</span><br></pre></td></tr></table></figure>\n<p>实现了call之后，apply也是同样的思路。</p>\n<p>===========================================</p>\n<h2 id=\"apply实现：\"><a href=\"#apply实现：\" class=\"headerlink\" title=\"apply实现：\"></a>apply实现：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newApply = function(context, parameter) &#123;</span><br><span class=\"line\">  if (typeof context === &apos;object&apos;) &#123;</span><br><span class=\"line\">    context = context || window</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    context = Object.create(null)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let fn = Symbol()</span><br><span class=\"line\">  context[fn] = this</span><br><span class=\"line\">  context[fn](...parameter);</span><br><span class=\"line\">  delete context[fn]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>初体验：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind = function (context) &#123;</span><br><span class=\"line\">  var me = this</span><br><span class=\"line\">  return function () &#123; // bind之后得到的函数</span><br><span class=\"line\">    return me.call(context)  // 执行是改变this执行</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">加入参数：</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.bind = function (context,...innerArgs) &#123;</span><br><span class=\"line\">  var me = this</span><br><span class=\"line\">  return function (...finnalyArgs) &#123;</span><br><span class=\"line\">    return me.call(context,...innerArgs,...finnalyArgs)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">  name: &apos;Abiel&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sayHi(age,sex) &#123;</span><br><span class=\"line\">  console.log(this.name, age, sex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let personSayHi = sayHi.bind(person, 25)</span><br><span class=\"line\">personSayHi(&apos;男&apos;)</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript 性能优化","date":"2017-02-24T03:31:12.000Z","_content":"1、尽量使用原生方法\n\n2、switch语句相对if较快\n\n通过将case语句按照最可能到最不可能的顺序进行组织\n\n3、位运算较快\n\n当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快\n\n4、巧用||和&&布尔运算符\n\n<!-- more -->\n\n# JavaScript 性能优化的小知识\n\n### 避免全局查找\n\n在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些\n\n    ```\n        function search() {\n            //当我要使用当前页面地址和主机域名\n            alert(window.location.href + window.location.host);\n        }\n        //最好的方式是如下这样  先用一个简单变量保存起来\n        function search() {\n            var location = window.location;\n            alert(location.href + location.host);\n        }    \n    ```\n \n\n\n### 定时器\n\n 如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器\n\n    ```\n        var timeoutTimes = 0;\n        function timeout() {\n            timeoutTimes++;\n            if (timeoutTimes < 10) {\n                setTimeout(timeout, 10);\n            }\n        }\n        timeout();\n        //可以替换为：\n        var intervalTimes = 0;\n        function interval() {\n            intervalTimes++;\n            if (intervalTimes >= 10) {\n                clearInterval(interv);\n            }\n        }\n        var interv = setInterval(interval, 10);        \n    ```\n \n\n\n### 字符串连接\n\n如果要连接多个字符串，应该少使用+=，如\n\ns+=a;\n\ns+=b;\n\ns+=c;\n\n应该写成s+=a + b + c；\n\n而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来\n    ```\n        var buf = [];\n        for (var i = 0; i < 100; i++) {\n            buf.push(i.toString());\n        }\n        var all = buf.join(\"\");\n     ```\n\n\n### 避免with语句\n\n和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。\n\n```\n with (a.b.c.d) {\n            property1 = 1;\n            property2 = 2;\n        }\n        //可以替换为：\n        var obj = a.b.c.d;\n        obj.property1 = 1;\n        obj.property2 = 2;\n```\n\n### 数字转换成字符串\n\n最好用\"\" + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：\n\n(\"\" +) > String() > .toString() > new String()\n\n\n### 浮点数转换成整型\n\n很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()\n\n\n### 各种类型转换\n\n```\nvar myVar = \"3.14159\",\n        str = \"\" + myVar, //  to string  \n        i_int = ~ ~myVar,  //  to integer  \n        f_float = 1 * myVar,  //  to float  \n        b_bool = !!myVar,  /*  to boolean - any string with length \n                                and any number except 0 are true */\n        array = [myVar];  //  to array  \n```\n如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高\n\n\n ###多个类型声明\n\n在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。\n\n### 使用直接量\n\n```\nvar aTest = new Array(); //替换为\n        var aTest = [];\n        var aTest = new Object; //替换为\n        var aTest = {};\n        var reg = new RegExp(); //替换为\n        var reg = /../;\n        //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：\n        var oFruit = new O;\n        oFruit.color = \"red\";\n        oFruit.name = \"apple\";\n        //前面的代码可用对象字面量来改写成这样：\n        var oFruit = { color: \"red\", name: \"apple\" };\n```\n\n### 使用DocumentFragment优化多次append\n\n一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。\n\n```\nfor (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            document.body.appendChild(el);\n        }\n        //可以替换为：\n        var frag = document.createDocumentFragment();\n        for (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n```\n\n### 使用一次innerHTML赋值代替构建dom元素\n\n对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。\n\n    ```\n        var frag = document.createDocumentFragment();\n        for (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n        //可以替换为：\n        var html = [];\n        for (var i = 0; i < 1000; i++) {\n            html.push('<p>' + i + '</p>');\n        }\n        document.body.innerHTML = html.join('');\n    ```\n\n### 通过模板元素clone，替代createElement\n\n很多人喜欢在JavaScript中使用document.write来给页面生成内容。  \n事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。  \n通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，  \n而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，  \n使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点\n\n    ```\n        var frag = document.createDocumentFragment();\n        for (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n        //替换为：\n        var frag = document.createDocumentFragment();\n        var pEl = document.getElementsByTagName('p')[0];\n        for (var i = 0; i < 1000; i++) {\n            var el = pEl.cloneNode(false);\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n    ```\n\n### 使用firstChild和nextSibling代替childNodes遍历dom元素\n\n \n\n    ```\n        var nodes = element.childNodes;\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            //……\n        }\n        //可以替换为：\n        var node = element.firstChild;\n        while (node) {\n            //……\n            node = node.nextSibling;\n    ```\n\n### 删除DOM节点\n\n删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。   \n另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点\n\n\n### 重复使用的调用结果，事先保存到局部变量\n\n    ```\n        //避免多次取值的调用开销\n        var h1 = element1.clientHeight + num1;\n        var h4 = element1.clientHeight + num2;\n        //可以替换为：\n        var eleHeight = element1.clientHeight;\n        var h1 = eleHeight + num1;\n        var h4 = eleHeight + num2;\n    ```\n\n### 注意NodeList\n\n最小化访问NodeList的次数可以极大的改进脚本的性能\n\n    ```\n      var images = document.getElementsByTagName('img');\n        for (var i = 0, len = images.length; i < len; i++) {\n\n        }\n    ```\n    \n编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问\n\n进行了对getElementsByTagName()的调用\n获取了元素的childNodes属性\n获取了元素的attributes属性\n访问了特殊的集合，如document.forms、document.images等等\n要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度\n\n\n### 优化循环\n\n可以使用下面几种方式来优化循环\n\n* 减值迭代\n大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效\n\n* 简化终止条件\n由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。\n\n    ```\n        var list = document.getElementsByTagName('p');\n        for (var i = 0; i < list.length; i++) {\n            //……\n        }\n\n        //替换为：\n        var list = document.getElementsByTagName('p');\n        for (var i = 0, l = list.length; i < l; i++) {\n            //……\n        }\n    ```\n* 简化循环体\n循环体是执行最多的，所以要确保其被最大限度的优化\n\n* 使用后测试循环\n在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。\n\n    ```\n        var arr = [1, 2, 3, 4, 5, 6, 7];\n        var sum = 0;\n        for (var i = 0, l = arr.length; i < l; i++) {\n            sum += arr[i];\n        }\n\n        //可以考虑替换为：\n\n        var arr = [1, 2, 3, 4, 5, 6, 7];\n        var sum = 0, l = arr.length;\n        while (l--) {\n            sum += arr[l];\n        }\n    ```\n    \n最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。\n\n\n* 展开循环\n\n当循环次数是确定的，消除循环并使用多次函数调用往往会更快。\n\n    \n### 使用常量\n\n重复值:任何在多处用到的值都应该抽取为一个常量  \n用户界面字符串:任何用于显示给用户的字符串，都应该抽取出来以方便国际化  \nURLs:在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL  \n任意可能会更改的值:每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。  \n\n### 避免与null进行比较\n\n由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换\n\n如果值应为一个引用类型，使用instanceof操作符检查其构造函数  \n如果值应为一个基本类型，作用typeof检查其类型  \n如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上  \n\n### 避免全局量\n\n全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。\n\n```\n//糟糕的全局变量和全局函数\nvar current = null;\nfunction init(){\n//...\n}\nfunction change() {\n    //...\n}\nfunction verify() {\n    //...\n}\n//解决办法有很多，Christian Heilmann建议的方法是：\n//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。\n(function(){\nvar current = null;\nfunction init() {\n    //...\n}\nfunction change() {\n    //...\n}\nfunction verify() {\n    //...\n}\n})();\n//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中\n//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据\nmyNameSpace = function() {\n    var current = null;\n\n    function init() {\n        //...\n    }\n\n    function change() {\n        //...\n    }\n\n    function verify() {\n        //...\n    }\n\n//所有需要在命名空间外调用的函数和属性都要写在return里面\n    return {\n        init: init,\n        //甚至你可以为函数和属性命名一个别名\n        set: change\n    };\n};\n```\n\n\n### 循环引用\n\n如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。\n\n简单的循环引用：\n    ```\n        var el = document.getElementById('MyElement');\n        var func = function () {\n            //…\n        }\n        el.func = func;\n        func.element = el;\n    ```\n但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。\n\n    ```\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n        }\n        init();\n    ```\ninit在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。\n\n下面2种方法可以解决循环引用：\n\n1)  置空dom对象\n\n    ```\n       function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n        }\n        init();\n        //可以替换为：\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n            el = null;\n        }\n        init();\n    ```\n将el置空，context中不包含对dom对象的引用，从而打断循环应用。\n\n如果我们需要将dom对象返回，可以用如下方法：\n\n    ```\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n            return el;\n        }\n        init();\n        //可以替换为：\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n            try {\n                return el;\n            } finally {\n                el = null;\n            }\n        }\n        init();\n    ```\n2)  构造新的context\n\n    ```\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n        }\n        init();\n        //可以替换为：\n        function elClickHandler() {\n            //……\n        }\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = elClickHandler;\n        }\n        init();\n    ```\n把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。\n\n\n### 释放dom元素占用的内存\n\n将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。\n\n在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。\n\n\n### 释放javascript对象\n\n在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。\n\n对象：obj = null\n\n对象属性：delete obj.myproperty\n\n数组item：使用数组的splice方法释放数组中不用的item\n\n\n### 松散耦合\n\n1、解耦HTML/JavaScript\n\nJavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的'script'元素、使用HTML属性来分配事件处理程序等\n\nHTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面\n\n其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离\n\n2、解耦CSS/JavaScript\n\n显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript\n\n3、解耦应用程序/事件处理程序\n\n将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试\n\n\n### 性能方面的注意事项\n\n1、尽量使用原生方法\n\n2、switch语句相对if较快\n\n通过将case语句按照最可能到最不可能的顺序进行组织\n\n3、位运算较快\n\n当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快\n\n4、巧用||和&&布尔运算符\n\n    ```\n        function eventHandler(e) {\n            if (!e) e = window.event;\n        }\n        //可以替换为：\n        function eventHandler(e) {\n            e = e || window.event;\n        }\n   \n        if (myobj) {\n            doSomething(myobj);\n        }\n        //可以替换为：\n        myobj && doSomething(myobj);\n    ```\n### 避免错误应注意的地方\n\n1、每条语句末尾须加分号\n\n在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误\n\n2、使用+号时需谨慎\n\nJavaScript 和其他编程语言不同的是，在 JavaScript 中，'+'除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符'++'混淆而引起计算错误\n    ```\n        var valueA = 20;\n        var valueB = \"10\";\n        alert(valueA + valueB);     //ouput: 2010 \n        alert(valueA + (+valueB));  //output: 30 \n        alert(valueA + +valueB);    //output:30 \n        alert(valueA ++ valueB);     //Compile error\n    ```\n3、使用return语句需要注意\n\n一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果\n\n    ```\n        function F1() {\n            var valueA = 1;\n            var valueB = 2;\n            return valueA + valueB;\n        }\n        function F2() {\n            var valueA = 1;\n            var valueB = 2;\n            return\n            valueA + valueB;\n        }\n        alert(F1());  //output: 3 \n        alert(F2());  //ouput: undefined\n    ```\n\n### ==和===的区别\n\n避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换\n\n    ```\n        var valueA = \"1\";\n        var valueB = 1;\n        if (valueA == valueB) {\n            alert(\"Equal\");\n        }\n        else {\n            alert(\"Not equal\");\n        }\n        //output: \"Equal\"\n        if (valueA === valueB) {\n            alert(\"Equal\");\n        }\n        else {\n            alert(\"Not equal\");\n        }\n        //output: \"Not equal\"\n    ```\n\n\n### 何时用单引号，何时用双引号\n\n虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号\n永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好\n\n","source":"_posts/javascript性能优化.md","raw":"---\ntitle: JavaScript 性能优化\ndate: 2017-02-24 11:31:12\ntags:\n---\n1、尽量使用原生方法\n\n2、switch语句相对if较快\n\n通过将case语句按照最可能到最不可能的顺序进行组织\n\n3、位运算较快\n\n当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快\n\n4、巧用||和&&布尔运算符\n\n<!-- more -->\n\n# JavaScript 性能优化的小知识\n\n### 避免全局查找\n\n在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些\n\n    ```\n        function search() {\n            //当我要使用当前页面地址和主机域名\n            alert(window.location.href + window.location.host);\n        }\n        //最好的方式是如下这样  先用一个简单变量保存起来\n        function search() {\n            var location = window.location;\n            alert(location.href + location.host);\n        }    \n    ```\n \n\n\n### 定时器\n\n 如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器\n\n    ```\n        var timeoutTimes = 0;\n        function timeout() {\n            timeoutTimes++;\n            if (timeoutTimes < 10) {\n                setTimeout(timeout, 10);\n            }\n        }\n        timeout();\n        //可以替换为：\n        var intervalTimes = 0;\n        function interval() {\n            intervalTimes++;\n            if (intervalTimes >= 10) {\n                clearInterval(interv);\n            }\n        }\n        var interv = setInterval(interval, 10);        \n    ```\n \n\n\n### 字符串连接\n\n如果要连接多个字符串，应该少使用+=，如\n\ns+=a;\n\ns+=b;\n\ns+=c;\n\n应该写成s+=a + b + c；\n\n而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来\n    ```\n        var buf = [];\n        for (var i = 0; i < 100; i++) {\n            buf.push(i.toString());\n        }\n        var all = buf.join(\"\");\n     ```\n\n\n### 避免with语句\n\n和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。\n\n```\n with (a.b.c.d) {\n            property1 = 1;\n            property2 = 2;\n        }\n        //可以替换为：\n        var obj = a.b.c.d;\n        obj.property1 = 1;\n        obj.property2 = 2;\n```\n\n### 数字转换成字符串\n\n最好用\"\" + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：\n\n(\"\" +) > String() > .toString() > new String()\n\n\n### 浮点数转换成整型\n\n很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()\n\n\n### 各种类型转换\n\n```\nvar myVar = \"3.14159\",\n        str = \"\" + myVar, //  to string  \n        i_int = ~ ~myVar,  //  to integer  \n        f_float = 1 * myVar,  //  to float  \n        b_bool = !!myVar,  /*  to boolean - any string with length \n                                and any number except 0 are true */\n        array = [myVar];  //  to array  \n```\n如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高\n\n\n ###多个类型声明\n\n在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。\n\n### 使用直接量\n\n```\nvar aTest = new Array(); //替换为\n        var aTest = [];\n        var aTest = new Object; //替换为\n        var aTest = {};\n        var reg = new RegExp(); //替换为\n        var reg = /../;\n        //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：\n        var oFruit = new O;\n        oFruit.color = \"red\";\n        oFruit.name = \"apple\";\n        //前面的代码可用对象字面量来改写成这样：\n        var oFruit = { color: \"red\", name: \"apple\" };\n```\n\n### 使用DocumentFragment优化多次append\n\n一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。\n\n```\nfor (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            document.body.appendChild(el);\n        }\n        //可以替换为：\n        var frag = document.createDocumentFragment();\n        for (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n```\n\n### 使用一次innerHTML赋值代替构建dom元素\n\n对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。\n\n    ```\n        var frag = document.createDocumentFragment();\n        for (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n        //可以替换为：\n        var html = [];\n        for (var i = 0; i < 1000; i++) {\n            html.push('<p>' + i + '</p>');\n        }\n        document.body.innerHTML = html.join('');\n    ```\n\n### 通过模板元素clone，替代createElement\n\n很多人喜欢在JavaScript中使用document.write来给页面生成内容。  \n事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。  \n通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，  \n而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，  \n使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点\n\n    ```\n        var frag = document.createDocumentFragment();\n        for (var i = 0; i < 1000; i++) {\n            var el = document.createElement('p');\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n        //替换为：\n        var frag = document.createDocumentFragment();\n        var pEl = document.getElementsByTagName('p')[0];\n        for (var i = 0; i < 1000; i++) {\n            var el = pEl.cloneNode(false);\n            el.innerHTML = i;\n            frag.appendChild(el);\n        }\n        document.body.appendChild(frag);\n    ```\n\n### 使用firstChild和nextSibling代替childNodes遍历dom元素\n\n \n\n    ```\n        var nodes = element.childNodes;\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            //……\n        }\n        //可以替换为：\n        var node = element.firstChild;\n        while (node) {\n            //……\n            node = node.nextSibling;\n    ```\n\n### 删除DOM节点\n\n删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。   \n另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点\n\n\n### 重复使用的调用结果，事先保存到局部变量\n\n    ```\n        //避免多次取值的调用开销\n        var h1 = element1.clientHeight + num1;\n        var h4 = element1.clientHeight + num2;\n        //可以替换为：\n        var eleHeight = element1.clientHeight;\n        var h1 = eleHeight + num1;\n        var h4 = eleHeight + num2;\n    ```\n\n### 注意NodeList\n\n最小化访问NodeList的次数可以极大的改进脚本的性能\n\n    ```\n      var images = document.getElementsByTagName('img');\n        for (var i = 0, len = images.length; i < len; i++) {\n\n        }\n    ```\n    \n编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问\n\n进行了对getElementsByTagName()的调用\n获取了元素的childNodes属性\n获取了元素的attributes属性\n访问了特殊的集合，如document.forms、document.images等等\n要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度\n\n\n### 优化循环\n\n可以使用下面几种方式来优化循环\n\n* 减值迭代\n大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效\n\n* 简化终止条件\n由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。\n\n    ```\n        var list = document.getElementsByTagName('p');\n        for (var i = 0; i < list.length; i++) {\n            //……\n        }\n\n        //替换为：\n        var list = document.getElementsByTagName('p');\n        for (var i = 0, l = list.length; i < l; i++) {\n            //……\n        }\n    ```\n* 简化循环体\n循环体是执行最多的，所以要确保其被最大限度的优化\n\n* 使用后测试循环\n在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。\n\n    ```\n        var arr = [1, 2, 3, 4, 5, 6, 7];\n        var sum = 0;\n        for (var i = 0, l = arr.length; i < l; i++) {\n            sum += arr[i];\n        }\n\n        //可以考虑替换为：\n\n        var arr = [1, 2, 3, 4, 5, 6, 7];\n        var sum = 0, l = arr.length;\n        while (l--) {\n            sum += arr[l];\n        }\n    ```\n    \n最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。\n\n\n* 展开循环\n\n当循环次数是确定的，消除循环并使用多次函数调用往往会更快。\n\n    \n### 使用常量\n\n重复值:任何在多处用到的值都应该抽取为一个常量  \n用户界面字符串:任何用于显示给用户的字符串，都应该抽取出来以方便国际化  \nURLs:在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL  \n任意可能会更改的值:每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。  \n\n### 避免与null进行比较\n\n由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换\n\n如果值应为一个引用类型，使用instanceof操作符检查其构造函数  \n如果值应为一个基本类型，作用typeof检查其类型  \n如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上  \n\n### 避免全局量\n\n全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。\n\n```\n//糟糕的全局变量和全局函数\nvar current = null;\nfunction init(){\n//...\n}\nfunction change() {\n    //...\n}\nfunction verify() {\n    //...\n}\n//解决办法有很多，Christian Heilmann建议的方法是：\n//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。\n(function(){\nvar current = null;\nfunction init() {\n    //...\n}\nfunction change() {\n    //...\n}\nfunction verify() {\n    //...\n}\n})();\n//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中\n//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据\nmyNameSpace = function() {\n    var current = null;\n\n    function init() {\n        //...\n    }\n\n    function change() {\n        //...\n    }\n\n    function verify() {\n        //...\n    }\n\n//所有需要在命名空间外调用的函数和属性都要写在return里面\n    return {\n        init: init,\n        //甚至你可以为函数和属性命名一个别名\n        set: change\n    };\n};\n```\n\n\n### 循环引用\n\n如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。\n\n简单的循环引用：\n    ```\n        var el = document.getElementById('MyElement');\n        var func = function () {\n            //…\n        }\n        el.func = func;\n        func.element = el;\n    ```\n但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。\n\n    ```\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n        }\n        init();\n    ```\ninit在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。\n\n下面2种方法可以解决循环引用：\n\n1)  置空dom对象\n\n    ```\n       function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n        }\n        init();\n        //可以替换为：\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n            el = null;\n        }\n        init();\n    ```\n将el置空，context中不包含对dom对象的引用，从而打断循环应用。\n\n如果我们需要将dom对象返回，可以用如下方法：\n\n    ```\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n            return el;\n        }\n        init();\n        //可以替换为：\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n            try {\n                return el;\n            } finally {\n                el = null;\n            }\n        }\n        init();\n    ```\n2)  构造新的context\n\n    ```\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = function () {\n                //……\n            }\n        }\n        init();\n        //可以替换为：\n        function elClickHandler() {\n            //……\n        }\n        function init() {\n            var el = document.getElementById('MyElement');\n            el.onclick = elClickHandler;\n        }\n        init();\n    ```\n把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。\n\n\n### 释放dom元素占用的内存\n\n将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。\n\n在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。\n\n\n### 释放javascript对象\n\n在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。\n\n对象：obj = null\n\n对象属性：delete obj.myproperty\n\n数组item：使用数组的splice方法释放数组中不用的item\n\n\n### 松散耦合\n\n1、解耦HTML/JavaScript\n\nJavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的'script'元素、使用HTML属性来分配事件处理程序等\n\nHTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面\n\n其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离\n\n2、解耦CSS/JavaScript\n\n显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript\n\n3、解耦应用程序/事件处理程序\n\n将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试\n\n\n### 性能方面的注意事项\n\n1、尽量使用原生方法\n\n2、switch语句相对if较快\n\n通过将case语句按照最可能到最不可能的顺序进行组织\n\n3、位运算较快\n\n当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快\n\n4、巧用||和&&布尔运算符\n\n    ```\n        function eventHandler(e) {\n            if (!e) e = window.event;\n        }\n        //可以替换为：\n        function eventHandler(e) {\n            e = e || window.event;\n        }\n   \n        if (myobj) {\n            doSomething(myobj);\n        }\n        //可以替换为：\n        myobj && doSomething(myobj);\n    ```\n### 避免错误应注意的地方\n\n1、每条语句末尾须加分号\n\n在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误\n\n2、使用+号时需谨慎\n\nJavaScript 和其他编程语言不同的是，在 JavaScript 中，'+'除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符'++'混淆而引起计算错误\n    ```\n        var valueA = 20;\n        var valueB = \"10\";\n        alert(valueA + valueB);     //ouput: 2010 \n        alert(valueA + (+valueB));  //output: 30 \n        alert(valueA + +valueB);    //output:30 \n        alert(valueA ++ valueB);     //Compile error\n    ```\n3、使用return语句需要注意\n\n一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果\n\n    ```\n        function F1() {\n            var valueA = 1;\n            var valueB = 2;\n            return valueA + valueB;\n        }\n        function F2() {\n            var valueA = 1;\n            var valueB = 2;\n            return\n            valueA + valueB;\n        }\n        alert(F1());  //output: 3 \n        alert(F2());  //ouput: undefined\n    ```\n\n### ==和===的区别\n\n避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换\n\n    ```\n        var valueA = \"1\";\n        var valueB = 1;\n        if (valueA == valueB) {\n            alert(\"Equal\");\n        }\n        else {\n            alert(\"Not equal\");\n        }\n        //output: \"Equal\"\n        if (valueA === valueB) {\n            alert(\"Equal\");\n        }\n        else {\n            alert(\"Not equal\");\n        }\n        //output: \"Not equal\"\n    ```\n\n\n### 何时用单引号，何时用双引号\n\n虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号\n永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好\n\n","slug":"javascript性能优化","published":1,"updated":"2019-01-30T03:11:48.000Z","_id":"cjrim0x8n0000fknxcc9oceyh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1、尽量使用原生方法</p>\n<p>2、switch语句相对if较快</p>\n<p>通过将case语句按照最可能到最不可能的顺序进行组织</p>\n<p>3、位运算较快</p>\n<p>当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快</p>\n<p>4、巧用||和&amp;&amp;布尔运算符</p>\n<a id=\"more\"></a>\n<h1 id=\"JavaScript-性能优化的小知识\"><a href=\"#JavaScript-性能优化的小知识\" class=\"headerlink\" title=\"JavaScript 性能优化的小知识\"></a>JavaScript 性能优化的小知识</h1><h3 id=\"避免全局查找\"><a href=\"#避免全局查找\" class=\"headerlink\" title=\"避免全局查找\"></a>避免全局查找</h3><p>在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function search() &#123;</span><br><span class=\"line\">    //当我要使用当前页面地址和主机域名</span><br><span class=\"line\">    alert(window.location.href + window.location.host);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//最好的方式是如下这样  先用一个简单变量保存起来</span><br><span class=\"line\">function search() &#123;</span><br><span class=\"line\">    var location = window.location;</span><br><span class=\"line\">    alert(location.href + location.host);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p> 如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var timeoutTimes = 0;</span><br><span class=\"line\">function timeout() &#123;</span><br><span class=\"line\">    timeoutTimes++;</span><br><span class=\"line\">    if (timeoutTimes &lt; 10) &#123;</span><br><span class=\"line\">        setTimeout(timeout, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">timeout();</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var intervalTimes = 0;</span><br><span class=\"line\">function interval() &#123;</span><br><span class=\"line\">    intervalTimes++;</span><br><span class=\"line\">    if (intervalTimes &gt;= 10) &#123;</span><br><span class=\"line\">        clearInterval(interv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var interv = setInterval(interval, 10);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><p>如果要连接多个字符串，应该少使用+=，如</p>\n<p>s+=a;</p>\n<p>s+=b;</p>\n<p>s+=c;</p>\n<p>应该写成s+=a + b + c；</p>\n<p>而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buf = [];</span><br><span class=\"line\">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">    buf.push(i.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var all = buf.join(&quot;&quot;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"避免with语句\"><a href=\"#避免with语句\" class=\"headerlink\" title=\"避免with语句\"></a>避免with语句</h3><p>和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with (a.b.c.d) &#123;</span><br><span class=\"line\">           property1 = 1;</span><br><span class=\"line\">           property2 = 2;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       //可以替换为：</span><br><span class=\"line\">       var obj = a.b.c.d;</span><br><span class=\"line\">       obj.property1 = 1;</span><br><span class=\"line\">       obj.property2 = 2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数字转换成字符串\"><a href=\"#数字转换成字符串\" class=\"headerlink\" title=\"数字转换成字符串\"></a>数字转换成字符串</h3><p>最好用”” + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：</p>\n<p>(“” +) &gt; String() &gt; .toString() &gt; new String()</p>\n<h3 id=\"浮点数转换成整型\"><a href=\"#浮点数转换成整型\" class=\"headerlink\" title=\"浮点数转换成整型\"></a>浮点数转换成整型</h3><p>很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()</p>\n<h3 id=\"各种类型转换\"><a href=\"#各种类型转换\" class=\"headerlink\" title=\"各种类型转换\"></a>各种类型转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myVar = &quot;3.14159&quot;,</span><br><span class=\"line\">        str = &quot;&quot; + myVar, //  to string  </span><br><span class=\"line\">        i_int = ~ ~myVar,  //  to integer  </span><br><span class=\"line\">        f_float = 1 * myVar,  //  to float  </span><br><span class=\"line\">        b_bool = !!myVar,  /*  to boolean - any string with length </span><br><span class=\"line\">                                and any number except 0 are true */</span><br><span class=\"line\">        array = [myVar];  //  to array</span><br></pre></td></tr></table></figure>\n<p>如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高</p>\n<p> ###多个类型声明</p>\n<p>在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。</p>\n<h3 id=\"使用直接量\"><a href=\"#使用直接量\" class=\"headerlink\" title=\"使用直接量\"></a>使用直接量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var aTest = new Array(); //替换为</span><br><span class=\"line\">        var aTest = [];</span><br><span class=\"line\">        var aTest = new Object; //替换为</span><br><span class=\"line\">        var aTest = &#123;&#125;;</span><br><span class=\"line\">        var reg = new RegExp(); //替换为</span><br><span class=\"line\">        var reg = /../;</span><br><span class=\"line\">        //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：</span><br><span class=\"line\">        var oFruit = new O;</span><br><span class=\"line\">        oFruit.color = &quot;red&quot;;</span><br><span class=\"line\">        oFruit.name = &quot;apple&quot;;</span><br><span class=\"line\">        //前面的代码可用对象字面量来改写成这样：</span><br><span class=\"line\">        var oFruit = &#123; color: &quot;red&quot;, name: &quot;apple&quot; &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用DocumentFragment优化多次append\"><a href=\"#使用DocumentFragment优化多次append\" class=\"headerlink\" title=\"使用DocumentFragment优化多次append\"></a>使用DocumentFragment优化多次append</h3><p>一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">            var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">            el.innerHTML = i;</span><br><span class=\"line\">            document.body.appendChild(el);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //可以替换为：</span><br><span class=\"line\">        var frag = document.createDocumentFragment();</span><br><span class=\"line\">        for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">            var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">            el.innerHTML = i;</span><br><span class=\"line\">            frag.appendChild(el);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        document.body.appendChild(frag);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用一次innerHTML赋值代替构建dom元素\"><a href=\"#使用一次innerHTML赋值代替构建dom元素\" class=\"headerlink\" title=\"使用一次innerHTML赋值代替构建dom元素\"></a>使用一次innerHTML赋值代替构建dom元素</h3><p>对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var frag = document.createDocumentFragment();</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">    el.innerHTML = i;</span><br><span class=\"line\">    frag.appendChild(el);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.appendChild(frag);</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var html = [];</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    html.push(&apos;&lt;p&gt;&apos; + i + &apos;&lt;/p&gt;&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.innerHTML = html.join(&apos;&apos;);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"通过模板元素clone，替代createElement\"><a href=\"#通过模板元素clone，替代createElement\" class=\"headerlink\" title=\"通过模板元素clone，替代createElement\"></a>通过模板元素clone，替代createElement</h3><p>很多人喜欢在JavaScript中使用document.write来给页面生成内容。<br>事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。<br>通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，<br>而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，<br>使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var frag = document.createDocumentFragment();</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">    el.innerHTML = i;</span><br><span class=\"line\">    frag.appendChild(el);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.appendChild(frag);</span><br><span class=\"line\">//替换为：</span><br><span class=\"line\">var frag = document.createDocumentFragment();</span><br><span class=\"line\">var pEl = document.getElementsByTagName(&apos;p&apos;)[0];</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    var el = pEl.cloneNode(false);</span><br><span class=\"line\">    el.innerHTML = i;</span><br><span class=\"line\">    frag.appendChild(el);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.appendChild(frag);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"使用firstChild和nextSibling代替childNodes遍历dom元素\"><a href=\"#使用firstChild和nextSibling代替childNodes遍历dom元素\" class=\"headerlink\" title=\"使用firstChild和nextSibling代替childNodes遍历dom元素\"></a>使用firstChild和nextSibling代替childNodes遍历dom元素</h3><pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nodes = element.childNodes;</span><br><span class=\"line\">for (var i = 0, l = nodes.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    var node = nodes[i];</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var node = element.firstChild;</span><br><span class=\"line\">while (node) &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">    node = node.nextSibling;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"删除DOM节点\"><a href=\"#删除DOM节点\" class=\"headerlink\" title=\"删除DOM节点\"></a>删除DOM节点</h3><p>删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。<br>另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点</p>\n<h3 id=\"重复使用的调用结果，事先保存到局部变量\"><a href=\"#重复使用的调用结果，事先保存到局部变量\" class=\"headerlink\" title=\"重复使用的调用结果，事先保存到局部变量\"></a>重复使用的调用结果，事先保存到局部变量</h3><pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//避免多次取值的调用开销</span><br><span class=\"line\">var h1 = element1.clientHeight + num1;</span><br><span class=\"line\">var h4 = element1.clientHeight + num2;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var eleHeight = element1.clientHeight;</span><br><span class=\"line\">var h1 = eleHeight + num1;</span><br><span class=\"line\">var h4 = eleHeight + num2;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"注意NodeList\"><a href=\"#注意NodeList\" class=\"headerlink\" title=\"注意NodeList\"></a>注意NodeList</h3><p>最小化访问NodeList的次数可以极大的改进脚本的性能</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var images = document.getElementsByTagName(&apos;img&apos;);</span><br><span class=\"line\">  for (var i = 0, len = images.length; i &lt; len; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p>编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问</p>\n<p>进行了对getElementsByTagName()的调用<br>获取了元素的childNodes属性<br>获取了元素的attributes属性<br>访问了特殊的集合，如document.forms、document.images等等<br>要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度</p>\n<h3 id=\"优化循环\"><a href=\"#优化循环\" class=\"headerlink\" title=\"优化循环\"></a>优化循环</h3><p>可以使用下面几种方式来优化循环</p>\n<ul>\n<li><p>减值迭代<br>大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效</p>\n</li>\n<li><p>简化终止条件<br>由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var list = document.getElementsByTagName(&apos;p&apos;);</span><br><span class=\"line\">for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//替换为：</span><br><span class=\"line\">var list = document.getElementsByTagName(&apos;p&apos;);</span><br><span class=\"line\">for (var i = 0, l = list.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简化循环体<br>循环体是执行最多的，所以要确保其被最大限度的优化</p>\n</li>\n<li><p>使用后测试循环<br>在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class=\"line\">var sum = 0;</span><br><span class=\"line\">for (var i = 0, l = arr.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    sum += arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//可以考虑替换为：</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class=\"line\">var sum = 0, l = arr.length;</span><br><span class=\"line\">while (l--) &#123;</span><br><span class=\"line\">    sum += arr[l];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。</p>\n<ul>\n<li>展开循环</li>\n</ul>\n<p>当循环次数是确定的，消除循环并使用多次函数调用往往会更快。</p>\n<h3 id=\"使用常量\"><a href=\"#使用常量\" class=\"headerlink\" title=\"使用常量\"></a>使用常量</h3><p>重复值:任何在多处用到的值都应该抽取为一个常量<br>用户界面字符串:任何用于显示给用户的字符串，都应该抽取出来以方便国际化<br>URLs:在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL<br>任意可能会更改的值:每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。  </p>\n<h3 id=\"避免与null进行比较\"><a href=\"#避免与null进行比较\" class=\"headerlink\" title=\"避免与null进行比较\"></a>避免与null进行比较</h3><p>由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换</p>\n<p>如果值应为一个引用类型，使用instanceof操作符检查其构造函数<br>如果值应为一个基本类型，作用typeof检查其类型<br>如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上  </p>\n<h3 id=\"避免全局量\"><a href=\"#避免全局量\" class=\"headerlink\" title=\"避免全局量\"></a>避免全局量</h3><p>全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//糟糕的全局变量和全局函数</span><br><span class=\"line\">var current = null;</span><br><span class=\"line\">function init()&#123;</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function change() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function verify() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//解决办法有很多，Christian Heilmann建议的方法是：</span><br><span class=\"line\">//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">var current = null;</span><br><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function change() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function verify() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中</span><br><span class=\"line\">//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据</span><br><span class=\"line\">myNameSpace = function() &#123;</span><br><span class=\"line\">    var current = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    function init() &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function change() &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function verify() &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//所有需要在命名空间外调用的函数和属性都要写在return里面</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        init: init,</span><br><span class=\"line\">        //甚至你可以为函数和属性命名一个别名</span><br><span class=\"line\">        set: change</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h3><p>如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。</p>\n<p>简单的循环引用：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">var func = function () &#123;</span><br><span class=\"line\">    //…</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">el.func = func;</span><br><span class=\"line\">func.element = el;</span><br></pre></td></tr></table></figure></p>\n<p>但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>init在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。</p>\n<p>下面2种方法可以解决循环引用：</p>\n<p>1)  置空dom对象</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">     var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">     el.onclick = function () &#123;</span><br><span class=\"line\">         //……</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> init();</span><br><span class=\"line\"> //可以替换为：</span><br><span class=\"line\"> function init() &#123;</span><br><span class=\"line\">     var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">     el.onclick = function () &#123;</span><br><span class=\"line\">         //……</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     el = null;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>将el置空，context中不包含对dom对象的引用，从而打断循环应用。</p>\n<p>如果我们需要将dom对象返回，可以用如下方法：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return el;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        el = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>2)  构造新的context</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">function elClickHandler() &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = elClickHandler;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。</p>\n<h3 id=\"释放dom元素占用的内存\"><a href=\"#释放dom元素占用的内存\" class=\"headerlink\" title=\"释放dom元素占用的内存\"></a>释放dom元素占用的内存</h3><p>将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。</p>\n<p>在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。</p>\n<h3 id=\"释放javascript对象\"><a href=\"#释放javascript对象\" class=\"headerlink\" title=\"释放javascript对象\"></a>释放javascript对象</h3><p>在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。</p>\n<p>对象：obj = null</p>\n<p>对象属性：delete obj.myproperty</p>\n<p>数组item：使用数组的splice方法释放数组中不用的item</p>\n<h3 id=\"松散耦合\"><a href=\"#松散耦合\" class=\"headerlink\" title=\"松散耦合\"></a>松散耦合</h3><p>1、解耦HTML/JavaScript</p>\n<p>JavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的’script’元素、使用HTML属性来分配事件处理程序等</p>\n<p>HTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面</p>\n<p>其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离</p>\n<p>2、解耦CSS/JavaScript</p>\n<p>显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript</p>\n<p>3、解耦应用程序/事件处理程序</p>\n<p>将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试</p>\n<h3 id=\"性能方面的注意事项\"><a href=\"#性能方面的注意事项\" class=\"headerlink\" title=\"性能方面的注意事项\"></a>性能方面的注意事项</h3><p>1、尽量使用原生方法</p>\n<p>2、switch语句相对if较快</p>\n<p>通过将case语句按照最可能到最不可能的顺序进行组织</p>\n<p>3、位运算较快</p>\n<p>当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快</p>\n<p>4、巧用||和&amp;&amp;布尔运算符</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function eventHandler(e) &#123;</span><br><span class=\"line\">    if (!e) e = window.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">function eventHandler(e) &#123;</span><br><span class=\"line\">    e = e || window.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">if (myobj) &#123;</span><br><span class=\"line\">    doSomething(myobj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">myobj &amp;&amp; doSomething(myobj);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"避免错误应注意的地方\"><a href=\"#避免错误应注意的地方\" class=\"headerlink\" title=\"避免错误应注意的地方\"></a>避免错误应注意的地方</h3><p>1、每条语句末尾须加分号</p>\n<p>在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误</p>\n<p>2、使用+号时需谨慎</p>\n<p>JavaScript 和其他编程语言不同的是，在 JavaScript 中，’+’除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符’++’混淆而引起计算错误<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var valueA = 20;</span><br><span class=\"line\">var valueB = &quot;10&quot;;</span><br><span class=\"line\">alert(valueA + valueB);     //ouput: 2010 </span><br><span class=\"line\">alert(valueA + (+valueB));  //output: 30 </span><br><span class=\"line\">alert(valueA + +valueB);    //output:30 </span><br><span class=\"line\">alert(valueA ++ valueB);     //Compile error</span><br></pre></td></tr></table></figure></p>\n<p>3、使用return语句需要注意</p>\n<p>一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function F1() &#123;</span><br><span class=\"line\">    var valueA = 1;</span><br><span class=\"line\">    var valueB = 2;</span><br><span class=\"line\">    return valueA + valueB;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function F2() &#123;</span><br><span class=\"line\">    var valueA = 1;</span><br><span class=\"line\">    var valueB = 2;</span><br><span class=\"line\">    return</span><br><span class=\"line\">    valueA + valueB;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(F1());  //output: 3 </span><br><span class=\"line\">alert(F2());  //ouput: undefined</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"和-的区别\"><a href=\"#和-的区别\" class=\"headerlink\" title=\"==和===的区别\"></a>==和===的区别</h3><p>避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var valueA = &quot;1&quot;;</span><br><span class=\"line\">var valueB = 1;</span><br><span class=\"line\">if (valueA == valueB) &#123;</span><br><span class=\"line\">    alert(&quot;Equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else &#123;</span><br><span class=\"line\">    alert(&quot;Not equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//output: &quot;Equal&quot;</span><br><span class=\"line\">if (valueA === valueB) &#123;</span><br><span class=\"line\">    alert(&quot;Equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else &#123;</span><br><span class=\"line\">    alert(&quot;Not equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//output: &quot;Not equal&quot;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"何时用单引号，何时用双引号\"><a href=\"#何时用单引号，何时用双引号\" class=\"headerlink\" title=\"何时用单引号，何时用双引号\"></a>何时用单引号，何时用双引号</h3><p>虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号<br>永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好</p>\n","site":{"data":{}},"excerpt":"<p>1、尽量使用原生方法</p>\n<p>2、switch语句相对if较快</p>\n<p>通过将case语句按照最可能到最不可能的顺序进行组织</p>\n<p>3、位运算较快</p>\n<p>当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快</p>\n<p>4、巧用||和&amp;&amp;布尔运算符</p>","more":"<h1 id=\"JavaScript-性能优化的小知识\"><a href=\"#JavaScript-性能优化的小知识\" class=\"headerlink\" title=\"JavaScript 性能优化的小知识\"></a>JavaScript 性能优化的小知识</h1><h3 id=\"避免全局查找\"><a href=\"#避免全局查找\" class=\"headerlink\" title=\"避免全局查找\"></a>避免全局查找</h3><p>在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function search() &#123;</span><br><span class=\"line\">    //当我要使用当前页面地址和主机域名</span><br><span class=\"line\">    alert(window.location.href + window.location.host);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//最好的方式是如下这样  先用一个简单变量保存起来</span><br><span class=\"line\">function search() &#123;</span><br><span class=\"line\">    var location = window.location;</span><br><span class=\"line\">    alert(location.href + location.host);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p> 如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var timeoutTimes = 0;</span><br><span class=\"line\">function timeout() &#123;</span><br><span class=\"line\">    timeoutTimes++;</span><br><span class=\"line\">    if (timeoutTimes &lt; 10) &#123;</span><br><span class=\"line\">        setTimeout(timeout, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">timeout();</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var intervalTimes = 0;</span><br><span class=\"line\">function interval() &#123;</span><br><span class=\"line\">    intervalTimes++;</span><br><span class=\"line\">    if (intervalTimes &gt;= 10) &#123;</span><br><span class=\"line\">        clearInterval(interv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var interv = setInterval(interval, 10);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h3><p>如果要连接多个字符串，应该少使用+=，如</p>\n<p>s+=a;</p>\n<p>s+=b;</p>\n<p>s+=c;</p>\n<p>应该写成s+=a + b + c；</p>\n<p>而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buf = [];</span><br><span class=\"line\">for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">    buf.push(i.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var all = buf.join(&quot;&quot;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"避免with语句\"><a href=\"#避免with语句\" class=\"headerlink\" title=\"避免with语句\"></a>避免with语句</h3><p>和函数类似 ，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的代码要慢，在能不使用with语句的时候尽量不要使用with语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with (a.b.c.d) &#123;</span><br><span class=\"line\">           property1 = 1;</span><br><span class=\"line\">           property2 = 2;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       //可以替换为：</span><br><span class=\"line\">       var obj = a.b.c.d;</span><br><span class=\"line\">       obj.property1 = 1;</span><br><span class=\"line\">       obj.property2 = 2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数字转换成字符串\"><a href=\"#数字转换成字符串\" class=\"headerlink\" title=\"数字转换成字符串\"></a>数字转换成字符串</h3><p>最好用”” + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：</p>\n<p>(“” +) &gt; String() &gt; .toString() &gt; new String()</p>\n<h3 id=\"浮点数转换成整型\"><a href=\"#浮点数转换成整型\" class=\"headerlink\" title=\"浮点数转换成整型\"></a>浮点数转换成整型</h3><p>很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()</p>\n<h3 id=\"各种类型转换\"><a href=\"#各种类型转换\" class=\"headerlink\" title=\"各种类型转换\"></a>各种类型转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myVar = &quot;3.14159&quot;,</span><br><span class=\"line\">        str = &quot;&quot; + myVar, //  to string  </span><br><span class=\"line\">        i_int = ~ ~myVar,  //  to integer  </span><br><span class=\"line\">        f_float = 1 * myVar,  //  to float  </span><br><span class=\"line\">        b_bool = !!myVar,  /*  to boolean - any string with length </span><br><span class=\"line\">                                and any number except 0 are true */</span><br><span class=\"line\">        array = [myVar];  //  to array</span><br></pre></td></tr></table></figure>\n<p>如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高</p>\n<p> ###多个类型声明</p>\n<p>在JavaScript中所有变量都可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。</p>\n<h3 id=\"使用直接量\"><a href=\"#使用直接量\" class=\"headerlink\" title=\"使用直接量\"></a>使用直接量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var aTest = new Array(); //替换为</span><br><span class=\"line\">        var aTest = [];</span><br><span class=\"line\">        var aTest = new Object; //替换为</span><br><span class=\"line\">        var aTest = &#123;&#125;;</span><br><span class=\"line\">        var reg = new RegExp(); //替换为</span><br><span class=\"line\">        var reg = /../;</span><br><span class=\"line\">        //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：</span><br><span class=\"line\">        var oFruit = new O;</span><br><span class=\"line\">        oFruit.color = &quot;red&quot;;</span><br><span class=\"line\">        oFruit.name = &quot;apple&quot;;</span><br><span class=\"line\">        //前面的代码可用对象字面量来改写成这样：</span><br><span class=\"line\">        var oFruit = &#123; color: &quot;red&quot;, name: &quot;apple&quot; &#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用DocumentFragment优化多次append\"><a href=\"#使用DocumentFragment优化多次append\" class=\"headerlink\" title=\"使用DocumentFragment优化多次append\"></a>使用DocumentFragment优化多次append</h3><p>一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">            var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">            el.innerHTML = i;</span><br><span class=\"line\">            document.body.appendChild(el);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //可以替换为：</span><br><span class=\"line\">        var frag = document.createDocumentFragment();</span><br><span class=\"line\">        for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">            var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">            el.innerHTML = i;</span><br><span class=\"line\">            frag.appendChild(el);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        document.body.appendChild(frag);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用一次innerHTML赋值代替构建dom元素\"><a href=\"#使用一次innerHTML赋值代替构建dom元素\" class=\"headerlink\" title=\"使用一次innerHTML赋值代替构建dom元素\"></a>使用一次innerHTML赋值代替构建dom元素</h3><p>对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var frag = document.createDocumentFragment();</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">    el.innerHTML = i;</span><br><span class=\"line\">    frag.appendChild(el);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.appendChild(frag);</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var html = [];</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    html.push(&apos;&lt;p&gt;&apos; + i + &apos;&lt;/p&gt;&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.innerHTML = html.join(&apos;&apos;);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"通过模板元素clone，替代createElement\"><a href=\"#通过模板元素clone，替代createElement\" class=\"headerlink\" title=\"通过模板元素clone，替代createElement\"></a>通过模板元素clone，替代createElement</h3><p>很多人喜欢在JavaScript中使用document.write来给页面生成内容。<br>事实上这样的效率较低，如果需要直接插入HTML，可以找一个容器元素，比如指定一个div或者span，并设置他们的innerHTML来将自己的HTML代码插入到页面中。<br>通常我们可能会使用字符串直接写HTML来创建节点，其实这样做，1无法保证代码的有效性2字符串操作效率低，所以应该是用document.createElement()方法，<br>而如果文档中存在现成的样板节点，应该是用cloneNode()方法，因为使用createElement()方法之后，你需要设置多次元素的属性，<br>使用cloneNode()则可以减少属性的设置次数——同样如果需要创建很多元素，应该先准备一个样板节点</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var frag = document.createDocumentFragment();</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    var el = document.createElement(&apos;p&apos;);</span><br><span class=\"line\">    el.innerHTML = i;</span><br><span class=\"line\">    frag.appendChild(el);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.appendChild(frag);</span><br><span class=\"line\">//替换为：</span><br><span class=\"line\">var frag = document.createDocumentFragment();</span><br><span class=\"line\">var pEl = document.getElementsByTagName(&apos;p&apos;)[0];</span><br><span class=\"line\">for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">    var el = pEl.cloneNode(false);</span><br><span class=\"line\">    el.innerHTML = i;</span><br><span class=\"line\">    frag.appendChild(el);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.body.appendChild(frag);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"使用firstChild和nextSibling代替childNodes遍历dom元素\"><a href=\"#使用firstChild和nextSibling代替childNodes遍历dom元素\" class=\"headerlink\" title=\"使用firstChild和nextSibling代替childNodes遍历dom元素\"></a>使用firstChild和nextSibling代替childNodes遍历dom元素</h3><pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nodes = element.childNodes;</span><br><span class=\"line\">for (var i = 0, l = nodes.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    var node = nodes[i];</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var node = element.firstChild;</span><br><span class=\"line\">while (node) &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">    node = node.nextSibling;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"删除DOM节点\"><a href=\"#删除DOM节点\" class=\"headerlink\" title=\"删除DOM节点\"></a>删除DOM节点</h3><p>删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。<br>另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点</p>\n<h3 id=\"重复使用的调用结果，事先保存到局部变量\"><a href=\"#重复使用的调用结果，事先保存到局部变量\" class=\"headerlink\" title=\"重复使用的调用结果，事先保存到局部变量\"></a>重复使用的调用结果，事先保存到局部变量</h3><pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//避免多次取值的调用开销</span><br><span class=\"line\">var h1 = element1.clientHeight + num1;</span><br><span class=\"line\">var h4 = element1.clientHeight + num2;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">var eleHeight = element1.clientHeight;</span><br><span class=\"line\">var h1 = eleHeight + num1;</span><br><span class=\"line\">var h4 = eleHeight + num2;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"注意NodeList\"><a href=\"#注意NodeList\" class=\"headerlink\" title=\"注意NodeList\"></a>注意NodeList</h3><p>最小化访问NodeList的次数可以极大的改进脚本的性能</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var images = document.getElementsByTagName(&apos;img&apos;);</span><br><span class=\"line\">  for (var i = 0, len = images.length; i &lt; len; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p>编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问</p>\n<p>进行了对getElementsByTagName()的调用<br>获取了元素的childNodes属性<br>获取了元素的attributes属性<br>访问了特殊的集合，如document.forms、document.images等等<br>要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度</p>\n<h3 id=\"优化循环\"><a href=\"#优化循环\" class=\"headerlink\" title=\"优化循环\"></a>优化循环</h3><p>可以使用下面几种方式来优化循环</p>\n<ul>\n<li><p>减值迭代<br>大多数循环使用一个从0开始、增加到某个特定值的迭代器，在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效</p>\n</li>\n<li><p>简化终止条件<br>由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，也就是说避免属性查找或者其它的操作，最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象的遍历时，提前将length保存到局部变量中，避免在循环的每一步重复取值。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var list = document.getElementsByTagName(&apos;p&apos;);</span><br><span class=\"line\">for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//替换为：</span><br><span class=\"line\">var list = document.getElementsByTagName(&apos;p&apos;);</span><br><span class=\"line\">for (var i = 0, l = list.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简化循环体<br>循环体是执行最多的，所以要确保其被最大限度的优化</p>\n</li>\n<li><p>使用后测试循环<br>在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class=\"line\">var sum = 0;</span><br><span class=\"line\">for (var i = 0, l = arr.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    sum += arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//可以考虑替换为：</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class=\"line\">var sum = 0, l = arr.length;</span><br><span class=\"line\">while (l--) &#123;</span><br><span class=\"line\">    sum += arr[l];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最常用的for循环和while循环都是前测试循环，而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。</p>\n<ul>\n<li>展开循环</li>\n</ul>\n<p>当循环次数是确定的，消除循环并使用多次函数调用往往会更快。</p>\n<h3 id=\"使用常量\"><a href=\"#使用常量\" class=\"headerlink\" title=\"使用常量\"></a>使用常量</h3><p>重复值:任何在多处用到的值都应该抽取为一个常量<br>用户界面字符串:任何用于显示给用户的字符串，都应该抽取出来以方便国际化<br>URLs:在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL<br>任意可能会更改的值:每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。  </p>\n<h3 id=\"避免与null进行比较\"><a href=\"#避免与null进行比较\" class=\"headerlink\" title=\"避免与null进行比较\"></a>避免与null进行比较</h3><p>由于JavaScript是弱类型的，所以它不会做任何的自动类型检查，所以如果看到与null进行比较的代码，尝试使用以下技术替换</p>\n<p>如果值应为一个引用类型，使用instanceof操作符检查其构造函数<br>如果值应为一个基本类型，作用typeof检查其类型<br>如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上  </p>\n<h3 id=\"避免全局量\"><a href=\"#避免全局量\" class=\"headerlink\" title=\"避免全局量\"></a>避免全局量</h3><p>全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//糟糕的全局变量和全局函数</span><br><span class=\"line\">var current = null;</span><br><span class=\"line\">function init()&#123;</span><br><span class=\"line\">//...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function change() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function verify() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//解决办法有很多，Christian Heilmann建议的方法是：</span><br><span class=\"line\">//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">var current = null;</span><br><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function change() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function verify() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中</span><br><span class=\"line\">//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据</span><br><span class=\"line\">myNameSpace = function() &#123;</span><br><span class=\"line\">    var current = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    function init() &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function change() &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function verify() &#123;</span><br><span class=\"line\">        //...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//所有需要在命名空间外调用的函数和属性都要写在return里面</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        init: init,</span><br><span class=\"line\">        //甚至你可以为函数和属性命名一个别名</span><br><span class=\"line\">        set: change</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h3><p>如果循环引用中包含DOM对象或者ActiveX对象，那么就会发生内存泄露。内存泄露的后果是在浏览器关闭前，即使是刷新页面，这部分内存不会被浏览器释放。</p>\n<p>简单的循环引用：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">var func = function () &#123;</span><br><span class=\"line\">    //…</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">el.func = func;</span><br><span class=\"line\">func.element = el;</span><br></pre></td></tr></table></figure></p>\n<p>但是通常不会出现这种情况。通常循环引用发生在为dom元素添加闭包作为expendo的时候。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>init在执行的时候，当前上下文我们叫做context。这个时候，context引用了el，el引用了function，function引用了context。这时候形成了一个循环引用。</p>\n<p>下面2种方法可以解决循环引用：</p>\n<p>1)  置空dom对象</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">     var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">     el.onclick = function () &#123;</span><br><span class=\"line\">         //……</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> init();</span><br><span class=\"line\"> //可以替换为：</span><br><span class=\"line\"> function init() &#123;</span><br><span class=\"line\">     var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">     el.onclick = function () &#123;</span><br><span class=\"line\">         //……</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     el = null;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>将el置空，context中不包含对dom对象的引用，从而打断循环应用。</p>\n<p>如果我们需要将dom对象返回，可以用如下方法：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return el;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        el = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>2)  构造新的context</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = function () &#123;</span><br><span class=\"line\">        //……</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">function elClickHandler() &#123;</span><br><span class=\"line\">    //……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function init() &#123;</span><br><span class=\"line\">    var el = document.getElementById(&apos;MyElement&apos;);</span><br><span class=\"line\">    el.onclick = elClickHandler;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">init();</span><br></pre></td></tr></table></figure>\n</code></pre><p>把function抽到新的context中，这样，function的context就不包含对el的引用，从而打断循环引用。</p>\n<h3 id=\"释放dom元素占用的内存\"><a href=\"#释放dom元素占用的内存\" class=\"headerlink\" title=\"释放dom元素占用的内存\"></a>释放dom元素占用的内存</h3><p>将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。</p>\n<p>在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。</p>\n<h3 id=\"释放javascript对象\"><a href=\"#释放javascript对象\" class=\"headerlink\" title=\"释放javascript对象\"></a>释放javascript对象</h3><p>在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。</p>\n<p>对象：obj = null</p>\n<p>对象属性：delete obj.myproperty</p>\n<p>数组item：使用数组的splice方法释放数组中不用的item</p>\n<h3 id=\"松散耦合\"><a href=\"#松散耦合\" class=\"headerlink\" title=\"松散耦合\"></a>松散耦合</h3><p>1、解耦HTML/JavaScript</p>\n<p>JavaScript和HTML的紧密耦合：直接写在HTML中的JavaScript、使用包含内联代码的’script’元素、使用HTML属性来分配事件处理程序等</p>\n<p>HTML和JavaScript的紧密耦合：JavaScript中包含HTML，然后使用innerHTML来插入一段html文本到页面</p>\n<p>其实应该是保持层次的分离，这样可以很容易的确定错误的来源，所以我们应确保HTML呈现应该尽可能与JavaScript保持分离</p>\n<p>2、解耦CSS/JavaScript</p>\n<p>显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript</p>\n<p>3、解耦应用程序/事件处理程序</p>\n<p>将应用逻辑和事件处理程序相分离：一个事件处理程序应该从事件对象中提取，并将这些信息传送给处理应用逻辑的某个方法中。这样做的好处首先可以让你更容易更改触发特定过程的事件，其次可以在不附加事件的情况下测试代码，使其更易创建单元测试</p>\n<h3 id=\"性能方面的注意事项\"><a href=\"#性能方面的注意事项\" class=\"headerlink\" title=\"性能方面的注意事项\"></a>性能方面的注意事项</h3><p>1、尽量使用原生方法</p>\n<p>2、switch语句相对if较快</p>\n<p>通过将case语句按照最可能到最不可能的顺序进行组织</p>\n<p>3、位运算较快</p>\n<p>当进行数字运算时，位运算操作要比任何布尔运算或者算数运算快</p>\n<p>4、巧用||和&amp;&amp;布尔运算符</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function eventHandler(e) &#123;</span><br><span class=\"line\">    if (!e) e = window.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">function eventHandler(e) &#123;</span><br><span class=\"line\">    e = e || window.event;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">if (myobj) &#123;</span><br><span class=\"line\">    doSomething(myobj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以替换为：</span><br><span class=\"line\">myobj &amp;&amp; doSomething(myobj);</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"避免错误应注意的地方\"><a href=\"#避免错误应注意的地方\" class=\"headerlink\" title=\"避免错误应注意的地方\"></a>避免错误应注意的地方</h3><p>1、每条语句末尾须加分号</p>\n<p>在if语句中，即使条件表达式只有一条语句也要用{}把它括起来，以免后续如果添加了语句之后造成逻辑错误</p>\n<p>2、使用+号时需谨慎</p>\n<p>JavaScript 和其他编程语言不同的是，在 JavaScript 中，’+’除了表示数字值相加，字符串相连接以外，还可以作一元运算符用，把字符串转换为数字。因而如果使用不当，则可能与自增符’++’混淆而引起计算错误<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var valueA = 20;</span><br><span class=\"line\">var valueB = &quot;10&quot;;</span><br><span class=\"line\">alert(valueA + valueB);     //ouput: 2010 </span><br><span class=\"line\">alert(valueA + (+valueB));  //output: 30 </span><br><span class=\"line\">alert(valueA + +valueB);    //output:30 </span><br><span class=\"line\">alert(valueA ++ valueB);     //Compile error</span><br></pre></td></tr></table></figure></p>\n<p>3、使用return语句需要注意</p>\n<p>一条有返回值的return语句不要用()括号来括住返回值，如果返回表达式，则表达式应与return关键字在同一行，以避免压缩时，压缩工具自动加分号而造成返回与开发人员不一致的结果</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function F1() &#123;</span><br><span class=\"line\">    var valueA = 1;</span><br><span class=\"line\">    var valueB = 2;</span><br><span class=\"line\">    return valueA + valueB;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function F2() &#123;</span><br><span class=\"line\">    var valueA = 1;</span><br><span class=\"line\">    var valueB = 2;</span><br><span class=\"line\">    return</span><br><span class=\"line\">    valueA + valueB;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(F1());  //output: 3 </span><br><span class=\"line\">alert(F2());  //ouput: undefined</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"和-的区别\"><a href=\"#和-的区别\" class=\"headerlink\" title=\"==和===的区别\"></a>==和===的区别</h3><p>避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var valueA = &quot;1&quot;;</span><br><span class=\"line\">var valueB = 1;</span><br><span class=\"line\">if (valueA == valueB) &#123;</span><br><span class=\"line\">    alert(&quot;Equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else &#123;</span><br><span class=\"line\">    alert(&quot;Not equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//output: &quot;Equal&quot;</span><br><span class=\"line\">if (valueA === valueB) &#123;</span><br><span class=\"line\">    alert(&quot;Equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else &#123;</span><br><span class=\"line\">    alert(&quot;Not equal&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//output: &quot;Not equal&quot;</span><br></pre></td></tr></table></figure>\n</code></pre><h3 id=\"何时用单引号，何时用双引号\"><a href=\"#何时用单引号，何时用双引号\" class=\"headerlink\" title=\"何时用单引号，何时用双引号\"></a>何时用单引号，何时用双引号</h3><p>虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号<br>永远不要忽略代码优化工作，重构是一项从项目开始到结束需要持续的工作，只有不断的优化代码才能让代码的执行效率越来越好</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}